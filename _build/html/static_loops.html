
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Loops in Static Symbolic Execution &#8212; Symbolic Execution: Foundations, Techniques, Applications and Future Perspectives</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/page.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Compositional Symbolic Execution" href="compositional.html" />
    <link rel="prev" title="Transparent Symbolic Execution of Function Calls" href="transparent_function_execution.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Symbolic Execution: Foundations, Techniques, Applications and Future Perspectives</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Introduction
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="minipy.html">
   Parser and Interpreter for minipy
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="foundations.html">
   Foundations
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="constraint_solving.html">
     Constraint Solving
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="semantics.html">
     Syntax and Semantics of Symbolic States
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="symbolic_interpreter.html">
     A Symbolic Interpreter and Correctness of Symbolic Transitions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="correctness.html">
     Correctness of Symbolic Transitions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="techniques.html">
   Techniques
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="transparent_function_execution.html">
     Transparent Symbolic Execution of Function Calls
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Loops in Static Symbolic Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="compositional.html">
     Compositional Symbolic Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="concolic.html">
     Concolic Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="stateexplosion.html">
     Tackling State Explosion
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="selective.html">
     Selective Symbolic Execution
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="applications.html">
   Applications
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="proving.html">
     Program Proving
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fuzzing.html">
     Symbolic Fuzzing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="debugging.html">
     Symbolic Debugging
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perspectives.html">
   Future Perspectives
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="conclusion.html">
   Conclusion
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/static_loops.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/rindPHI/se-book-festschrift-rh"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/rindPHI/se-book-festschrift-rh/issues/new?title=Issue%20on%20page%20%2Fstatic_loops.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loop-invariant-reasoning-using-program-transformation">
   Loop Invariant Reasoning using Program Transformation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loop-scopes">
   Loop Scopes
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#grammar-parser-and-mechanized-semantics">
     Grammar, Parser, and Mechanized Semantics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#symbolic-execution-of-loop-scopes">
     Symbolic Execution of Loop Scopes
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="loops-in-static-symbolic-execution">
<span id="techniques-loops-static-se"></span><h1>Loops in Static Symbolic Execution<a class="headerlink" href="#loops-in-static-symbolic-execution" title="Permalink to this headline">¶</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">utils</span>
<span class="kn">from</span> <span class="nn">minipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">transparent_function_execution</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
</div>
<p>Loops are a standard obstacle in symbolic execution. The dynamic / concolic variants of SE use concrete inputs as guides, which ensures the termination of the analysis even in the presence of symbolic loop guards. In static SE, termination is easiest ensured by <em>bounded</em> unwinding (see <a class="reference internal" href="symbolic_interpreter.html#foundations-symbolic-interpreter"><span class="std std-ref">A Symbolic Interpreter and Correctness of Symbolic Transitions</span></a>). However, this impedes the construction of an <em>exhaustive</em> symbolic execution procedure (see <a class="reference internal" href="correctness.html#foundations-correctness"><span class="std std-ref">Correctness of Symbolic Transitions</span></a>), as generally some loop paths will not be covered if the number of loop executions is not bound by a constant.</p>
<p>The standard way to deal with unbounded loops in exhaustive symbolic execution are <em>loop invariants</em> <span id="id1">[<a class="reference internal" href="#id260"><span>Hoa69</span></a>]</span>. Essentially, a loop invariant is an assertion satisfied by the loop after any number of iterations (i.e., the the assertion is <em>invariant</em> with respect to the number of completed loop iterations). Thus, we can abstract a loop by its invariant and continue symbolic execution.</p>
<p>To prove that a formula <span class="math notranslate nohighlight">\(\mathit{Inv}\)</span> is indeed a loop invariant in the first place, we have to assert that</p>
<ol class="simple">
<li><p>(<em>Initially Valid</em>) <span class="math notranslate nohighlight">\(\mathit{Inv}\)</span> holds initially, that is, right before the <em>very first</em> loop iteration, and</p></li>
<li><p>(<em>Preserved</em>) if <span class="math notranslate nohighlight">\(\mathit{Inv}\)</span> holds at the beginning of an <em>arbitrary</em> iteration, <span class="math notranslate nohighlight">\(\mathit{Inv}\)</span> also holds right before the next iteration.</p></li>
</ol>
<p>In rule-based symbolic execution systems, loop invariant-based reasoning is performed by loop invariant rules (see, e.g., <span id="id2">[<a class="reference internal" href="#id217"><span>DE82</span></a>]</span> <span id="id3">[<a class="reference internal" href="transparent_function_execution.html#id173"><span>ABB+16</span></a>]</span>). Alternatively, we can encode the above two proof cases as well as the case where we assume the invariant and resume symbolic execution (the “Use Case”) into the program. This approach, which is, for example, followed by the Boogie verifier <span id="id4">[<a class="reference internal" href="#id183"><span>BCD+05</span></a>]</span>, requires two additional statement types: (1) <em>havoc statements</em> <code class="docutils literal notranslate"><span class="pre">havoc</span> <span class="pre">x</span></code> erase the currently assigned value for the variable <code class="docutils literal notranslate"><span class="pre">x</span></code> in the symbolic store, assigning it a fresh, symbolic value; and (2) <em>assume statements</em> <code class="docutils literal notranslate"><span class="pre">assume</span> <span class="pre">expr</span></code>, which add the boolean expression <code class="docutils literal notranslate"><span class="pre">expr</span></code> to the path condition.</p>
<p>Assuming these verification-only statements, we transform a loop as follows, where <code class="docutils literal notranslate"><span class="pre">Inv</span></code> is a loop invariant and <code class="docutils literal notranslate"><span class="pre">x_1</span></code> to <code class="docutils literal notranslate"><span class="pre">x_n</span></code> are the variables written in the loop body: A loop statement</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">guard</span><span class="p">:</span>
    <span class="n">body</span>
    
<span class="n">remaining_program</span>
</pre></div>
</div>
<p>is transformed to</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Inv</span>        <span class="c1"># Initially Valid</span>

<span class="n">havoc</span> <span class="n">x_1</span>
<span class="n">havoc</span> <span class="n">x_2</span>
<span class="n">havoc</span> <span class="o">...</span>
<span class="n">havoc</span> <span class="n">x_n</span>
<span class="n">assume</span> <span class="n">Inv</span>

<span class="k">if</span> <span class="n">guard</span><span class="p">:</span>
    <span class="n">body</span>
    <span class="k">assert</span> <span class="n">Inv</span>    <span class="c1"># Preserved</span>
    <span class="n">assume</span> <span class="kc">False</span>

<span class="n">remaining_program</span> <span class="c1"># Use Case</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">assume</span> <span class="pre">False</span></code> after the “Preserved” assertion indicates that we reached a code path which does not exit the loop and preserves <code class="docutils literal notranslate"><span class="pre">Inv</span></code> (since the assertion before was satisfied). Assuming <code class="docutils literal notranslate"><span class="pre">False</span></code> leads to a symbolic state with unsatisfiable path condition, such that symbolic execution stops at that point.</p>
<p>Consider, for example, the following program computing the product of all integers in a tuple <code class="docutils literal notranslate"><span class="pre">t</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">elem</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    
<span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>One loop invariant for this program is <span class="math notranslate nohighlight">\(\mathtt{i}\geq{}0\wedge\mathtt{i}\leq\mathtt{len(t)}\land\texttt{result % elem} = 0\)</span>, informally “<code class="docutils literal notranslate"><span class="pre">i</span></code> ranges between 0 (before the loop) and, inclusively, <code class="docutils literal notranslate"><span class="pre">len(t)</span></code> (after loop termination), and the current tuple element is a factor of <code class="docutils literal notranslate"><span class="pre">result</span></code>”.</p>
<p>Let <code class="docutils literal notranslate"><span class="pre">Inv(i,</span> <span class="pre">t,</span> <span class="pre">result)</span></code> denote the invariant expression. Then, the product computation program is transformed to</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">elem</span> <span class="o">=</span> <span class="mi">1</span> 

<span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="n">havoc</span> <span class="n">i</span>
<span class="n">havoc</span> <span class="n">elem</span>
<span class="n">havoc</span> <span class="n">result</span>
<span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">elem</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="n">assume</span> <span class="kc">False</span>

<span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<div class="section" id="loop-invariant-reasoning-using-program-transformation">
<h2>Loop Invariant Reasoning using Program Transformation<a class="headerlink" href="#loop-invariant-reasoning-using-program-transformation" title="Permalink to this headline">¶</a></h2>
<p>To enable this program transformation-based approach to loop invariant reasoning, we add <code class="docutils literal notranslate"><span class="pre">havoc</span></code> and <code class="docutils literal notranslate"><span class="pre">assume</span></code> statements to minipy and the symbolic interpreter. Since these statements work with symbolic expressions and manipulate path constraints, it does not make much sense to integrate them also in the concrete minipy interpreter.</p>
<p>We first extend the minipy grammar.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#% EXPORT</span>
<span class="n">MINIPY_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;simple_stmt&gt;&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;&lt;havoc_stmt&gt;&quot;</span><span class="p">)</span>
<span class="n">MINIPY_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;simple_stmt&gt;&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;&lt;assume_stmt&gt;&quot;</span><span class="p">)</span>
<span class="n">MINIPY_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;havoc_stmt&gt;&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;havoc &lt;NAME&gt;&quot;</span><span class="p">]</span>
<span class="n">MINIPY_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;assume_stmt&gt;&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;assume &lt;expression&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we add AST node classes, extend the AST converter, and re-declare the <code class="docutils literal notranslate"><span class="pre">parse</span></code> function to use the new <code class="docutils literal notranslate"><span class="pre">ASTConverter</span></code> version.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Havoc</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;havoc &quot;</span> <span class="o">+</span> <span class="n">variable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Assume</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;assume &quot;</span> <span class="o">+</span> <span class="n">expression</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Assume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ASTConverter</span><span class="p">(</span><span class="n">ASTConverter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="s2">&quot;&lt;havoc_stmt&gt;&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_havoc_stmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="s2">&quot;&lt;assume_stmt&gt;&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_assume_stmt</span>
        
    <span class="k">def</span> <span class="nf">transform_havoc_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;havoc &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Havoc</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="k">def</span> <span class="nf">transform_assume_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;assume &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Assume</span><span class="p">(</span><span class="n">eval_expr_result</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">inp</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">strip_comments_and_whitespace</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">PythonPEGParser</span><span class="p">(</span><span class="n">MINIPY_GRAMMAR</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">inp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ASTConverter</span><span class="p">()</span><span class="o">.</span><span class="n">transform_top</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we extend the symbolic interpreter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">z3_fresh_sequence</span><span class="p">(</span><span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">elem_sort</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">elem_sort</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="k">if</span> <span class="n">elem_sort</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">elem_sort</span>
    <span class="k">return</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqRef</span><span class="p">(</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">Z3_mk_fresh_const</span><span class="p">(</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span>
            <span class="n">prefix</span><span class="p">,</span>
            <span class="n">z3</span><span class="o">.</span><span class="n">SeqSortRef</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Z3_mk_seq_sort</span><span class="p">(</span><span class="n">elem_sort</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">elem_sort</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span>
        <span class="n">ctx</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">(</span><span class="n">SymbolicInterpreter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">loop_unrolling_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">predicates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loop_unrolling_threshold</span><span class="p">,</span> <span class="n">predicates</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="n">Havoc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_havoc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="n">Assume</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_assume_stmt</span>
        
    <span class="k">def</span> <span class="nf">execute_havoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Havoc</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This variable has not been assigned a value yet, so there is nothing to havoc</span>
            <span class="k">return</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">[])]</span>

        <span class="n">new_env</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="n">new_env</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">z3</span><span class="o">.</span><span class="n">FreshInt</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">INT_TYPE</span> <span class="k">else</span>
            <span class="n">z3</span><span class="o">.</span><span class="n">FreshBool</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BOOL_TYPE</span> <span class="k">else</span>
            <span class="n">z3_fresh_sequence</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">new_environment</span> <span class="o">=</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="n">SymbolicStore</span><span class="p">(</span><span class="n">new_env</span><span class="p">),</span>
                                              <span class="n">environment</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">,</span>
                                              <span class="n">environment</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">,</span>
                                              <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">new_environment</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">[])]</span>

    <span class="k">def</span> <span class="nf">execute_assume_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Assert</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="n">children</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_expr_result</span><span class="p">:</span>
            <span class="n">new_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">new_env</span> <span class="o">=</span> <span class="n">new_env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">)</span>
                <span class="n">new_env</span> <span class="o">=</span> <span class="n">new_env</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">new_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">new_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>Now, we can symbolically execute our transformed product computation program with invariant reasoning:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">program_with_invariants</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">i = 0</span>
<span class="s2">result = 1</span>
<span class="s2">elem = 1 </span>

<span class="s2">assert Inv(i, t, elem, result)</span>

<span class="s2">havoc i</span>
<span class="s2">havoc elem</span>
<span class="s2">havoc result</span>
<span class="s2">assume Inv(i, t, elem, result)</span>

<span class="s2">if i &lt; len(t):</span>
<span class="s2">    elem = t[i]</span>
<span class="s2">    result = result * elem</span>
<span class="s2">    i = i + 1</span>
<span class="s2">    assert Inv(i, t, elem, result)</span>
<span class="s2">    assume False</span>

<span class="s2">return result</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">program_with_invariants_ast</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">program_with_invariants</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">program_with_invariants_ast</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">elem</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="n">havoc</span> <span class="n">i</span>
<span class="n">havoc</span> <span class="n">elem</span>
<span class="n">havoc</span> <span class="n">result</span>
<span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">*</span> <span class="n">elem</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="n">assume</span> <span class="kc">False</span>
<span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>Instead of using standard minipy expressions for the assertions (which would also have been possible here), we introduce a predicate <code class="docutils literal notranslate"><span class="pre">Inv</span></code> for the invariant. This has two advantages: First, it enables us to store the invariant formula at a central place, which makes it easier to change it in case of problems. And second, that way we can go <em>beyond</em> mere minipy assertions when designing loop invariants. Most importantly, we can use existential and universal <em>quantifiers</em>. An example for an invariant with quantifiers is provided further below.</p>
<div class="cell tag_full-width tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">invariant</span> <span class="o">=</span> <span class="p">(</span>
    <span class="k">lambda</span> <span class="n">iv</span><span class="p">,</span> <span class="n">tv</span><span class="p">,</span> <span class="n">elemv</span><span class="p">,</span> <span class="n">resultv</span><span class="p">:</span>
    <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span>
        <span class="n">iv</span> <span class="o">&gt;=</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">iv</span> <span class="o">&lt;=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="n">tv</span><span class="p">),</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">Or</span><span class="p">(</span>
            <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span>
                <span class="n">elemv</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="n">resultv</span> <span class="o">==</span>  <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span>
                <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">elemv</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
                <span class="n">resultv</span> <span class="o">%</span> <span class="n">elemv</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">))))</span>

<span class="n">interpreter</span> <span class="o">=</span> <span class="n">SymbolicInterpreter</span><span class="p">(</span><span class="n">predicates</span><span class="o">=</span><span class="p">{</span>
    <span class="s2">&quot;Inv&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqSort</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">()),</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">()),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolSort</span><span class="p">(),</span> <span class="n">invariant</span><span class="p">),</span>
    <span class="s2">&quot;len&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">SeqSort</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">()),),</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">)</span>
<span class="p">})</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">TUPLE_TYPE</span><span class="p">)</span>
<span class="n">environment</span> <span class="o">=</span> <span class="n">SymbolicEnvironment</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">to_z3</span><span class="p">())</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">program_with_invariants_ast</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="n">display_set</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/static_loops_17_0.svg" src="_images/static_loops_17_0.svg" /></div>
</div>
<p>Since there are no red nodes in the SET, all invariant checks were passed, and we also did not miss any other exceptional cases! Let us check what happens if we <em>add</em> <code class="docutils literal notranslate"><span class="pre">elem</span></code> to <code class="docutils literal notranslate"><span class="pre">result</span></code> instead of computing the product:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">faulty_program_with_invariants</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">i = 0</span>
<span class="s2">result = 1</span>
<span class="s2">elem = 1 </span>

<span class="s2">assert Inv(i, t, elem, result)</span>

<span class="s2">havoc i</span>
<span class="s2">havoc elem</span>
<span class="s2">havoc result</span>
<span class="s2">assume Inv(i, t, elem, result)</span>

<span class="s2">if i &lt; len(t):</span>
<span class="s2">    elem = t[i]</span>
<span class="s2">    result = result + elem  # &lt;-- &quot;+&quot;&quot; instead of *</span>
<span class="s2">    i = i + 1</span>
<span class="s2">    assert Inv(i, t, elem, result)</span>
<span class="s2">    assume False</span>

<span class="s2">return result</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">faulty_program_with_invariants_ast</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">faulty_program_with_invariants</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">faulty_program_with_invariants_ast</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">elem</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="n">havoc</span> <span class="n">i</span>
<span class="n">havoc</span> <span class="n">elem</span>
<span class="n">havoc</span> <span class="n">result</span>
<span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">+</span> <span class="n">elem</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="n">assume</span> <span class="kc">False</span>
<span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_full-width tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">TUPLE_TYPE</span><span class="p">)</span>
<span class="n">environment</span> <span class="o">=</span> <span class="n">SymbolicEnvironment</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">to_z3</span><span class="p">())</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">faulty_program_with_invariants_ast</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="n">display_set</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/static_loops_20_0.svg" src="_images/static_loops_20_0.svg" /></div>
</div>
<p>Now, there is a red node with an <code class="docutils literal notranslate"><span class="pre">AssertionError</span></code>: As expected, our buggy program mutant does not satisfy the loop invariant.</p>
<p>Next, we have a look at a slightly more complex example: A program <em>filtering</em> tuple values, retaining only the positive ones.</p>
<div class="cell tag_minipy docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">filter_nonnegative</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">filter_nonnegative</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">321</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(3, 17, 0, 5)
</pre></div>
</div>
</div>
</div>
<p>We transform the body of the <code class="docutils literal notranslate"><span class="pre">filter_nonnegative</span></code> function according to our “loop invariants with program transformation” approach:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">filter_program_with_invariants</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">i = 0</span>
<span class="s2">result = tuple() </span>

<span class="s2">assert Inv(i, t, result)</span>

<span class="s2">havoc i</span>
<span class="s2">havoc result</span>
<span class="s2">assume Inv(i, t, result)</span>

<span class="s2">if i &lt; len(t):</span>
<span class="s2">    if t[i] &gt;= 0:</span>
<span class="s2">        result = result + (t[i], )</span>
<span class="s2">    i = i + 1</span>
<span class="s2">    assert Inv(i, t, result)</span>
<span class="s2">    assume False</span>

<span class="s2">return result </span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">filter_program_with_invariants_ast</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">filter_program_with_invariants</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">filter_program_with_invariants_ast</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="n">havoc</span> <span class="n">i</span>
<span class="n">havoc</span> <span class="n">result</span>
<span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">))</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="n">assume</span> <span class="kc">False</span>
<span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>The invariant maintained by this program is</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code> stays between 0 and the size of <code class="docutils literal notranslate"><span class="pre">t</span></code></p></li>
<li><p>the size of <code class="docutils literal notranslate"><span class="pre">result</span></code> does not exceed the size of <code class="docutils literal notranslate"><span class="pre">iv</span></code></p></li>
<li><p>all nonnegative elements of <code class="docutils literal notranslate"><span class="pre">t</span></code> up to (exclusively) index <code class="docutils literal notranslate"><span class="pre">i</span></code> are contained in <code class="docutils literal notranslate"><span class="pre">result</span></code></p></li>
</ol>
<div class="cell tag_output_scroll tag_full-width docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">kv</span><span class="p">,</span> <span class="n">lv</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;k l&quot;</span><span class="p">)</span>
<span class="n">invariant</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">iv</span><span class="p">,</span> <span class="n">tv</span><span class="p">,</span> <span class="n">resultv</span><span class="p">:</span> \
    <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span>
        <span class="n">iv</span> <span class="o">&gt;=</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">iv</span> <span class="o">&lt;=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="n">tv</span><span class="p">),</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="n">resultv</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">iv</span><span class="p">,</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="p">(</span>
            <span class="p">[</span><span class="n">kv</span><span class="p">],</span>
            <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span>
                <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">kv</span><span class="p">,</span> <span class="n">kv</span> <span class="o">&lt;</span> <span class="n">iv</span><span class="p">),</span>
                <span class="n">z3</span><span class="o">.</span><span class="n">Or</span><span class="p">(</span>
                    <span class="n">tv</span><span class="p">[</span><span class="n">kv</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">z3</span><span class="o">.</span><span class="n">Exists</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">lv</span><span class="p">],</span>
                        <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span>
                            <span class="n">lv</span> <span class="o">&gt;=</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                            <span class="n">lv</span> <span class="o">&lt;</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="n">resultv</span><span class="p">),</span>
                            <span class="n">resultv</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span> <span class="o">==</span> <span class="n">tv</span><span class="p">[</span><span class="n">kv</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)))))</span>

<span class="n">interpreter</span> <span class="o">=</span> <span class="n">SymbolicInterpreter</span><span class="p">(</span><span class="n">predicates</span><span class="o">=</span><span class="p">{</span>
    <span class="s2">&quot;Inv&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqSort</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">()),</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">()),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolSort</span><span class="p">(),</span> <span class="n">invariant</span><span class="p">),</span>
    <span class="s2">&quot;len&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">SeqSort</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">()),),</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">)</span>
<span class="p">})</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">TUPLE_TYPE</span><span class="p">)</span>
<span class="n">environment</span> <span class="o">=</span> <span class="n">SymbolicEnvironment</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">to_z3</span><span class="p">())</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">filter_program_with_invariants_ast</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="n">display_set</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/static_loops_27_0.svg" src="_images/static_loops_27_0.svg" /></div>
</div>
<p>Note that the invariant occurs in the path constraint of the blue SET node (the “use case”). For any code following the loop, we can (and have to) therefore rely on the information encoded in the loop invariant when accessing values changed by the loop: The loop invariant is an <em>abstraction</em> of the loop’s behavior. In <a class="reference internal" href="proving.html#applications-proving"><span class="std std-ref">Program Proving</span></a>, we will have a look at the role of loop invariants in <em>program proving</em>. Reasonable loop invariants should at least exclude non-feasible exceptions raised in the code following the loop (e.g., by limiting the range of variables used for indexing tuples). To show stronger properties (e.g., functional postconditions), we also have to come up with stronger loop invariants.</p>
<p>For a final example, we return to the linear search program:</p>
<div class="cell tag_minipy docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">needle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">haystack</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">:</span>
            <span class="k">break</span>
            
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
</div>
</div>
<p>Applying the code transformation as before yields (we only show the function’s body):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>

<span class="n">havoc</span> <span class="n">i</span>
<span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>

<span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">:</span>
        <span class="k">break</span>
            
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
    <span class="n">assume</span> <span class="kc">False</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">return</span> <span class="n">i</span> 
</pre></div>
</div>
<p>Obviously, we missed something: What do we do about the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement, which now appears outside any <code class="docutils literal notranslate"><span class="pre">while</span></code> statement? To preserve its semantics, we have to change the program such that no loop code is executed after hitting the <code class="docutils literal notranslate"><span class="pre">break</span></code>. For this simple example, this is not too difficult:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>

<span class="n">havoc</span> <span class="n">i</span>
<span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>

<span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">:</span>
        <span class="k">pass</span>  <span class="c1"># &lt;-- formerly break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
        <span class="n">assume</span> <span class="kc">False</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">return</span> <span class="n">i</span> 
</pre></div>
</div>
<p>It suffices to replace the <code class="docutils literal notranslate"><span class="pre">break</span></code> by a <code class="docutils literal notranslate"><span class="pre">pass</span></code> and to embed the remaining loop code inside the <code class="docutils literal notranslate"><span class="pre">else</span></code> branch of the <code class="docutils literal notranslate"><span class="pre">if</span></code>. Turning this idea into an automated, general transformation still remains a major challenge with potentially many special cases to consider.</p>
</div>
<div class="section" id="loop-scopes">
<h2>Loop Scopes<a class="headerlink" href="#loop-scopes" title="Permalink to this headline">¶</a></h2>
<p>An alternative approach which does not require any program transformation of loop bodies was proposed in <span id="id5">[<a class="reference internal" href="#id34"><span>SteinhofelW17</span></a>]</span>. This work introduces so-called <em>loop scope statements</em>, which are similar in spirit to the method frames described in <a class="reference internal" href="transparent_function_execution.html#techniques-transparent-function-execution"><span class="std std-ref">Transparent Symbolic Execution of Function Calls</span></a>. The idea is that we do not need to transform, for example, the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement above. Instead, a <code class="docutils literal notranslate"><span class="pre">break</span></code> statement may legally occur within a loop scope, which “swallows” it and completes normally.</p>
<p>The original loop scope statements from <span id="id6">[<a class="reference internal" href="#id34"><span>SteinhofelW17</span></a>]</span> are statements of the form</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">body</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the boolean <em>index variable</em> of the loop scope and <code class="docutils literal notranslate"><span class="pre">body</span></code> its body. Their intuitive semantics is that <code class="docutils literal notranslate"><span class="pre">x</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> if, and only if, <code class="docutils literal notranslate"><span class="pre">body</span></code> completes abruptly because of a <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement, and is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> otherwise. That is, <code class="docutils literal notranslate"><span class="pre">x</span></code> indicates if the loop has been <em>exited</em>. Loop scopes were implemented for the rule-based symbolic execution engine KeY<a class="footnote-reference brackets" href="#key" id="id7">1</a>. There, the value of <code class="docutils literal notranslate"><span class="pre">x</span></code> is then used in an updated postcondition to distinguish whether the loop invariant or the original postcondition has to be shown. It turns out that in our symbolic minipy interpreter, the index <code class="docutils literal notranslate"><span class="pre">x</span></code> is not needed, since we can simply “catch” the abrupt completion behavior of <code class="docutils literal notranslate"><span class="pre">body</span></code> and proceed accordingly.</p>
<p>In <span id="id8">[<a class="reference internal" href="#id71"><span>Steinhofel20</span></a>]</span>, loop scopes are given a precise, non-mechanized semantics. We adapt this definition to minipy, which involves both changes to the syntax <em>and</em> semantics of loop scopes. Syntactically, we drop the loop scope index <code class="docutils literal notranslate"><span class="pre">x</span></code>, and instead require a boolean expression as argument: The loop invariant. The syntax of minipy loop scopes is</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">inv</span><span class="o">=</span><span class="n">expr</span><span class="p">):</span>
    <span class="n">body</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">expr</span></code> is a boolean expression. We also change the semantics; most notably, we check the invariant if the <code class="docutils literal notranslate"><span class="pre">body</span></code> completes due to a <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement, and either terminate the execution if the invariant is satisfied (cf. the addition of <code class="docutils literal notranslate"><span class="pre">False</span></code> to the path constraint in case of the transformation-based approach) or raise an <code class="docutils literal notranslate"><span class="pre">AssertionError</span></code>. Subsequently, we provide a more precise description.</p>
<p>A loop scope statement is executed by first executing the body <code class="docutils literal notranslate"><span class="pre">body</span></code>. Then there is a choice:</p>
<ul class="simple">
<li><p>If execution of <code class="docutils literal notranslate"><span class="pre">body</span></code> completes normally, the behavior of the loop scope statement is undefined.</p></li>
<li><p>If execution of <code class="docutils literal notranslate"><span class="pre">body</span></code> completes abruptly because of a <code class="docutils literal notranslate"><span class="pre">break</span></code>, the loop scope statement completes normally.</p></li>
<li><p>If execution of <code class="docutils literal notranslate"><span class="pre">body</span></code> completes abruptly because of a <code class="docutils literal notranslate"><span class="pre">continue</span></code>, there is a choice:</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">expr</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the execution (of the whole program) completes normally.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">expr</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the loop scopes statement completes abruptly because of an <code class="docutils literal notranslate"><span class="pre">AssertionError</span></code>.</p></li>
</ul>
</li>
<li><p>If execution of <code class="docutils literal notranslate"><span class="pre">body</span></code> completes abruptly for any other reason, the loop scope statement completes abruptly for the same reason.</p></li>
</ul>
<p>This facilitates a different kind of program transformation for loop invariant-based symbolic execution of loops which leaves loop <em>bodies</em> fully intact. A <code class="docutils literal notranslate"><span class="pre">while</span></code> loop with guard <code class="docutils literal notranslate"><span class="pre">guard</span></code>, body <code class="docutils literal notranslate"><span class="pre">body</span></code>, assigned locations <code class="docutils literal notranslate"><span class="pre">x_1</span></code> to <code class="docutils literal notranslate"><span class="pre">x_n</span></code> and invariant expression <code class="docutils literal notranslate"><span class="pre">Inv</span></code> is transformed to</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Inv</span>

<span class="n">havoc</span> <span class="n">x_1</span>
<span class="c1"># ...</span>
<span class="n">havoc</span> <span class="n">x_n</span>
<span class="n">assume</span> <span class="n">Inv</span>

<span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">inv</span><span class="o">=</span><span class="n">Inv</span><span class="p">):</span>    
    <span class="k">if</span> <span class="n">guard</span><span class="p">:</span>
        <span class="n">body</span>
        <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div>
</div>
<p>If the loop has an <code class="docutils literal notranslate"><span class="pre">else</span></code> branch with body <code class="docutils literal notranslate"><span class="pre">else_body</span></code>, we retain this branch, adding a trailing <code class="docutils literal notranslate"><span class="pre">else</span></code> statement. We obtain</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Inv</span>

<span class="n">havoc</span> <span class="n">x_1</span>
<span class="c1"># ...</span>
<span class="n">havoc</span> <span class="n">x_n</span>
<span class="n">assume</span> <span class="n">Inv</span>

<span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">inv</span><span class="o">=</span><span class="n">Inv</span><span class="p">):</span>    
    <span class="k">if</span> <span class="n">guard</span><span class="p">:</span>
        <span class="n">body</span>
        <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">else_body</span>
        <span class="k">break</span>
</pre></div>
</div>
<p>Observe that it is not possible for the body of the loop scope to complete normally. If the original <code class="docutils literal notranslate"><span class="pre">body</span></code> completes normally, the newly added <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement is reached and the loop invariant checked. If the guard evaluates to <code class="docutils literal notranslate"><span class="pre">False</span></code>, we hit the added <code class="docutils literal notranslate"><span class="pre">break</span></code> statement, leading to the classic <em>use case</em> of loop invariant reasoning.</p>
<div class="section" id="grammar-parser-and-mechanized-semantics">
<h3>Grammar, Parser, and Mechanized Semantics<a class="headerlink" href="#grammar-parser-and-mechanized-semantics" title="Permalink to this headline">¶</a></h3>
<p>Let us implement loop scopes for minipy. First, as usual, we extend the grammar, add AST node classes and extend the ASTConverter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">MINIPY_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;compound_stmt&gt;&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&lt;loop_scope&gt;&quot;</span><span class="p">)</span>
<span class="n">MINIPY_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;loop_scope&gt;&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;loop-scope(inv=&lt;expression&gt;):&lt;block&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LoopScope</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inv</span><span class="p">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;loop-scope(inv=</span><span class="si">{</span><span class="n">inv</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">):</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv</span> <span class="o">=</span> <span class="n">inv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">LoopScope</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ASTConverter</span><span class="p">(</span><span class="n">ASTConverter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="s2">&quot;&lt;loop_scope&gt;&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_loop_scope_stmt</span>
        
    <span class="k">def</span> <span class="nf">transform_loop_scope_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LoopScope</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;loop-scope(inv=&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;):&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">LoopScope</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_block</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">inp</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ASTNode&#39;</span><span class="p">:</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">strip_comments_and_whitespace</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">PythonPEGParser</span><span class="p">(</span><span class="n">MINIPY_GRAMMAR</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">inp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ASTConverter</span><span class="p">()</span><span class="o">.</span><span class="n">transform_top</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">find_loop_scopes</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">i = 0</span>

<span class="s2">assert Inv(i, needle, haystack)</span>

<span class="s2">havoc i</span>
<span class="s2">assume Inv(i, needle, haystack)</span>

<span class="s2">loop-scope(inv=Inv(i, needle, haystack)):</span>
<span class="s2">    if i &lt; len(haystack):</span>
<span class="s2">        if haystack[i] == needle:</span>
<span class="s2">            break</span>
<span class="s2">        </span>
<span class="s2">        i = i + 1</span>
<span class="s2">        continue</span>
<span class="s2">    else:</span>
<span class="s2">        return -1</span>
<span class="s2">        break</span>

<span class="s2">return i </span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">find_loop_scopes_ast</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">find_loop_scopes</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">find_loop_scopes_ast</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
<span class="n">havoc</span> <span class="n">i</span>
<span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
<span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">inv</span><span class="o">=</span><span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">break</span>
<span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
</div>
</div>
<p>As we did for method frames in <a class="reference internal" href="transparent_function_execution.html#techniques-transparent-function-execution"><span class="std std-ref">Transparent Symbolic Execution of Function Calls</span></a>, we can mechanize the semantics of loop scopes by implementing their behavior in the concrete minipy interpreter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Interpreter</span><span class="p">(</span><span class="n">Interpreter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="n">LoopScope</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_loop_scope</span>
        
    <span class="k">def</span> <span class="nf">execute_loop_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">LoopScope</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="k">assert</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">Break</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">Continue</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">inv</span><span class="p">,</span> <span class="n">environment</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">Halt</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loop scope invariant </span><span class="si">{</span><span class="n">stmt</span><span class="o">.</span><span class="n">inv</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2"> not satisfied.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span>
</pre></div>
</div>
</div>
</div>
<p>For experimenting with this implementation, we use a simple loop iterating over a tuple and performing special actions for the magic values 17 and 42:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">17</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">42</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Assuming the invariant <code class="docutils literal notranslate"><span class="pre">inv</span> <span class="pre">&gt;=</span> <span class="pre">0</span> <span class="pre">and</span> <span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">len(t)</span></code>, transforming loop as explained above for invariant-based symbolic execution with loop scopes yields the following loop scope statement:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">loop_scope_program</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">loop-scope(inv=i &gt;= 0 and i &lt;= len(t)):</span>
<span class="s2">    if i &lt; len(t):</span>
<span class="s2">        if i == 17:</span>
<span class="s2">            break</span>
<span class="s2">        if i == 42:</span>
<span class="s2">            return i + 1</span>
<span class="s2">            </span>
<span class="s2">        i = i + 1</span>
<span class="s2">        continue</span>
<span class="s2">    else:</span>
<span class="s2">        break</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">loop_scope_program_ast</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">loop_scope_program</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">loop_scope_program_ast</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">inv</span><span class="o">=</span><span class="p">((</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">17</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">42</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div>
</div>
</div>
</div>
<p>If the loop is entered and the <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement reached, the invariant is verified. If this succeeds, the execution completes due to a raised <code class="docutils literal notranslate"><span class="pre">Halt</span></code> exception (which is a special exception type signaling abrupt completion of the execution for a reason other than an error).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">TUPLE_TYPE</span><span class="p">)</span>

<span class="n">interpreter</span> <span class="o">=</span> <span class="n">Interpreter</span><span class="p">()</span>

<span class="n">environment</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="n">environment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">environment</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">loop_scope_program_ast</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="k">except</span> <span class="n">Halt</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invariant satisfied (Halt raised). i=</span><span class="si">{</span><span class="n">environment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Invariant satisfied (Halt raised). i=4
</pre></div>
</div>
</div>
</div>
<p>If the value of index <code class="docutils literal notranslate"><span class="pre">i</span></code> exceeds the tuple size, the loop body is not executed and the <code class="docutils literal notranslate"><span class="pre">break</span></code> statement hit instead. The value of <code class="docutils literal notranslate"><span class="pre">i</span></code> is not changed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">environment</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="n">environment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Out of bounds; loop body not entered</span>
<span class="n">environment</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">loop_scope_program_ast</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Program completed normally. i=</span><span class="si">{</span><span class="n">environment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Program completed normally. i=6
</pre></div>
</div>
</div>
</div>
<p>The magic value 17 induces an abrupt completion of the body due to a <code class="docutils literal notranslate"><span class="pre">break</span></code> statement. The loop scope completes normally, <code class="docutils literal notranslate"><span class="pre">i</span></code> remains unchanged.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">environment</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="n">environment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">17</span>  <span class="c1"># Magic value</span>
<span class="n">environment</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)])</span>

<span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">loop_scope_program_ast</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Program completed normally. i=</span><span class="si">{</span><span class="n">environment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Program completed normally. i=17
</pre></div>
</div>
</div>
</div>
<p>For the magic value 42, a <code class="docutils literal notranslate"><span class="pre">return</span></code> is executed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">environment</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="n">environment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>  <span class="c1"># Magic value</span>
<span class="n">environment</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)])</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">loop_scope_program_ast</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="k">except</span> <span class="n">Return</span> <span class="k">as</span> <span class="n">ret</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Program completed because of a return of </span><span class="si">{</span><span class="n">ret</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">. i=</span><span class="si">{</span><span class="n">environment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Program completed because of a return of 43. i=42
</pre></div>
</div>
</div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">i</span></code> is not initialized before the loop and the loop guard only checks if <code class="docutils literal notranslate"><span class="pre">i</span></code> is too <em>big</em>, we can assign it a negative initial value leading to a violation of the loop invariant.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">environment</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="n">environment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>  <span class="c1"># out of bounds, but still enters loop body</span>
<span class="n">environment</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">loop_scope_program_ast</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loop invariant not satisfied. i=</span><span class="si">{</span><span class="n">environment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Loop invariant not satisfied. i=-2
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="symbolic-execution-of-loop-scopes">
<h3>Symbolic Execution of Loop Scopes<a class="headerlink" href="#symbolic-execution-of-loop-scopes" title="Permalink to this headline">¶</a></h3>
<p>Extending the symbolic interpreter with loop scope support is not too difficult since we can copy the code for the most difficult part, the checking of the invariant in the case of a completion due to a <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement, from the method handling <code class="docutils literal notranslate"><span class="pre">assert</span></code> statements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">(</span><span class="n">SymbolicInterpreter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">loop_unrolling_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">predicates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loop_unrolling_threshold</span><span class="p">,</span> <span class="n">predicates</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="n">LoopScope</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_loop_scope</span>
        
    <span class="k">def</span> <span class="nf">execute_loop_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">LoopScope</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[</span><span class="n">tree</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
            <span class="n">leaf_node</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">leaf</span>
            <span class="n">environment</span> <span class="o">=</span> <span class="n">leaf_node</span><span class="o">.</span><span class="n">environment</span>
            <span class="n">exc</span> <span class="o">=</span> <span class="n">leaf_node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">abrupt_completion</span>

            <span class="k">assert</span> <span class="n">exc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">Break</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">replace_in_tree</span><span class="p">(</span>
                    <span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">leaf_node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span> <span class="p">[]))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">Continue</span><span class="p">):</span>
                <span class="n">eval_inv_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">inv</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                <span class="n">children</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_inv_result</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                        <span class="n">exc_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span>
                                            <span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
                                            <span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[])</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">exc_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc_node</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">)</span>
                        <span class="n">sat_env</span> <span class="o">=</span> <span class="p">(</span><span class="n">environment</span>
                                   <span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
                                   <span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                   <span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">Halt</span><span class="p">()))</span>
                        <span class="n">viol_env</span> <span class="o">=</span> <span class="p">(</span><span class="n">environment</span>
                                    <span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
                                    <span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                                    <span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="ne">AssertionError</span><span class="p">()))</span>

                        <span class="k">if</span> <span class="n">sat_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">viol_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
                        <span class="k">elif</span> <span class="n">viol_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">sat_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">sat_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
                            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">viol_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>As an example for demonstrating the result of this implementation, we take our linear search program. Its loop invariant is “i stays within 0 and the size of haystack (inclusively), and we did not find <code class="docutils literal notranslate"><span class="pre">needle</span></code> at all previous indexes”.</p>
<div class="cell tag_full-width docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">kv</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Int</span><span class="p">(</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
<span class="n">invariant</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">iv</span><span class="p">,</span> <span class="n">needlev</span><span class="p">,</span> <span class="n">haystackv</span><span class="p">:</span> \
    <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span>
        <span class="n">iv</span> <span class="o">&gt;=</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">iv</span> <span class="o">&lt;=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="n">haystackv</span><span class="p">),</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="p">(</span>
            <span class="p">[</span><span class="n">kv</span><span class="p">],</span>
            <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span>
                <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">kv</span><span class="p">,</span> <span class="n">kv</span> <span class="o">&lt;</span> <span class="n">iv</span><span class="p">),</span>
                <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">haystackv</span><span class="p">[</span><span class="n">kv</span><span class="p">]</span> <span class="o">==</span> <span class="n">needlev</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

<span class="n">interpreter</span> <span class="o">=</span> <span class="n">SymbolicInterpreter</span><span class="p">(</span><span class="n">predicates</span><span class="o">=</span><span class="p">{</span>
    <span class="s2">&quot;Inv&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqSort</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">())),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolSort</span><span class="p">(),</span> <span class="n">invariant</span><span class="p">),</span>
    <span class="s2">&quot;len&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">SeqSort</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">()),),</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">)</span>
<span class="p">})</span>

<span class="n">needle</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;needle&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)</span>
<span class="n">haystack</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;haystack&quot;</span><span class="p">,</span> <span class="n">TUPLE_TYPE</span><span class="p">)</span>
<span class="n">environment</span> <span class="o">=</span> <span class="n">SymbolicEnvironment</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">haystack</span><span class="p">,</span> <span class="n">haystack</span><span class="o">.</span><span class="n">to_z3</span><span class="p">())</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">needle</span><span class="p">,</span> <span class="n">needle</span><span class="o">.</span><span class="n">to_z3</span><span class="p">())</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">find_loop_scopes_ast</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="n">display_set</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/static_loops_56_0.svg" src="_images/static_loops_56_0.svg" /></div>
</div>
<p>What happens if we add a small bug into our implementation? Assume we typed <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">i</span></code> instead <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code> (which is not entirely impossible):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">find_loop_scopes_buggy</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">i = 0</span>

<span class="s2">assert Inv(i, needle, haystack)</span>

<span class="s2">havoc i</span>
<span class="s2">assume Inv(i, needle, haystack)</span>

<span class="s2">loop-scope(inv=Inv(i, needle, haystack)):</span>
<span class="s2">    if i &lt; len(haystack):</span>
<span class="s2">        if haystack[i] == needle:</span>
<span class="s2">            break</span>

<span class="s2">        i = i + i</span>
<span class="s2">        continue</span>
<span class="s2">    else:</span>
<span class="s2">        return -1</span>
<span class="s2">        break</span>

<span class="s2">return i </span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">find_loop_scopes_buggy_ast</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">find_loop_scopes_buggy</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">find_loop_scopes_buggy_ast</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
<span class="n">havoc</span> <span class="n">i</span>
<span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
<span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">inv</span><span class="o">=</span><span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">break</span>
<span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_full-width docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">find_loop_scopes_buggy_ast</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="n">display_set</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/static_loops_59_0.svg" src="_images/static_loops_59_0.svg" /></div>
</div>
<p>Now, we get an <code class="docutils literal notranslate"><span class="pre">AssertionError</span></code> node after the SET node for the <code class="docutils literal notranslate"><span class="pre">continue</span></code> statement, since the invariant is not preserved by the code.</p>
<p>The only missing puzzle piece is an automatic transformation from loops into loop scopes. Since we do not have to perform transformations inside loop bodies, this is easy to implement. First, however, we define another visitor class to retrieve assigned loop locations for the introduction of the <code class="docutils literal notranslate"><span class="pre">havoc</span></code> statements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AssignedVariablesVisitor</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">kwargs</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">)</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Assignment</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_assigned_variables</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">visitor</span> <span class="o">=</span> <span class="n">AssignedVariablesVisitor</span><span class="p">()</span>
        <span class="n">node</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">visitor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">visitor</span><span class="o">.</span><span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">LoopScopeTransformer</span></code> class itself is straightforward. It requires a mapping from loop statements to invariant expressions which we insert into the loop scope statements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LoopScopeTransformer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invariants</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">WhileStmt</span><span class="p">,</span> <span class="n">Expression</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invariants</span> <span class="o">=</span> <span class="n">invariants</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">kwargs</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">)</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">WhileStmt</span><span class="p">):</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">invariants</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="n">assigned_vars</span> <span class="o">=</span> <span class="n">AssignedVariablesVisitor</span><span class="o">.</span><span class="n">get_assigned_variables</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="n">result_stmts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ASTNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Assert</span><span class="p">(</span><span class="n">inv</span><span class="p">)]</span>
            <span class="n">result_stmts</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">Havoc</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">assigned_vars</span><span class="p">])</span>
            <span class="n">result_stmts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Assume</span><span class="p">(</span><span class="n">inv</span><span class="p">))</span>

            <span class="n">body</span> <span class="o">=</span> <span class="n">IfStmt</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span>
                <span class="n">Block</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">stmts</span> <span class="o">+</span> <span class="p">[</span><span class="n">ContinueStmt</span><span class="p">()]),</span>
                <span class="n">Block</span><span class="p">(([]</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">node</span><span class="o">.</span><span class="n">else_block</span><span class="o">.</span><span class="n">stmts</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">BreakStmt</span><span class="p">()])</span>
            <span class="p">)</span>

            <span class="n">result_stmts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LoopScope</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">Block</span><span class="p">([</span><span class="n">body</span><span class="p">])))</span>

            <span class="k">return</span> <span class="n">Stmts</span><span class="p">(</span><span class="n">result_stmts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span>
</pre></div>
</div>
</div>
</div>
<p>We transform the body of our linear search program:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">find_program</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">i = 0</span>
<span class="s2">while i &lt; len(haystack):</span>
<span class="s2">    if haystack[i] == needle:</span>
<span class="s2">        break</span>

<span class="s2">    i = i + 1</span>
<span class="s2">else:</span>
<span class="s2">    return -1</span>

<span class="s2">return i</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">find_program_ast</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">find_program</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">find_program_ast</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">):</span>
        <span class="k">break</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
</div>
</div>
<p>The transformation requires that we first extract the loop statement for assigning it its invariant.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">loop_stmt</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span>
    <span class="n">FilterASTVisitor</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">find_program_ast</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">WhileStmt</span><span class="p">))))</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">loop_stmt</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">):</span>
        <span class="k">break</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">loop_scope_transformer</span> <span class="o">=</span> <span class="n">LoopScopeTransformer</span><span class="p">({</span><span class="n">loop_stmt</span><span class="p">:</span> <span class="n">parse_expr</span><span class="p">(</span><span class="s2">&quot;Inv(i, needle, haystack)&quot;</span><span class="p">)})</span>
<span class="n">find_loop_scopes</span> <span class="o">=</span> <span class="n">find_program_ast</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">loop_scope_transformer</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">find_loop_scopes</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
<span class="n">havoc</span> <span class="n">i</span>
<span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
<span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">inv</span><span class="o">=</span><span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">break</span>
<span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
</div>
</div>
<p>This looks as expected! As promised in <a class="reference internal" href="transparent_function_execution.html#techniques-transparent-function-execution"><span class="std std-ref">Transparent Symbolic Execution of Function Calls</span></a>, we can combine (chain) the transformers for loop scopes and method frames, such that the full version of the linear search program including the method call can be transformed and transparently executed symbolically:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">find_program_with_func_decl</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def find(needle: int, haystack: tuple) -&gt; int:</span>
<span class="s2">    i = 0</span>
<span class="s2">    while i &lt; len(haystack):</span>
<span class="s2">        if haystack[i] == needle:</span>
<span class="s2">            break</span>
<span class="s2">            </span>
<span class="s2">        i = i + 1</span>
<span class="s2">    else:</span>
<span class="s2">        return -1</span>
<span class="s2">    </span>
<span class="s2">    return i</span>

<span class="s2">result = find(needle, haystack)</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">find_program_with_func_decl_ast</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">find_program_with_func_decl</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">find_program_with_func_decl_ast</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">needle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">haystack</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">find_program_with_func_decl_loop_scopes</span> <span class="o">=</span> \
    <span class="n">find_program_with_func_decl_ast</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">loop_scope_transformer</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">find_program_with_func_decl_loop_scopes</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">needle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">haystack</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
    <span class="n">havoc</span> <span class="n">i</span>
    <span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">inv</span><span class="o">=</span><span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">i</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">method_frame_transformer</span> <span class="o">=</span> <span class="n">MethodFrameTransformer</span><span class="p">(</span><span class="n">find_program_with_func_decl_loop_scopes</span><span class="p">)</span>
<span class="n">find_program_with_func_decl_loop_scopes_method_frames</span> <span class="o">=</span> \
    <span class="n">find_program_with_func_decl_loop_scopes</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">method_frame_transformer</span><span class="p">)</span>
<span class="n">display_program</span><span class="p">(</span><span class="n">find_program_with_func_decl_loop_scopes_method_frames</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">needle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">haystack</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
    <span class="n">havoc</span> <span class="n">i</span>
    <span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">inv</span><span class="o">=</span><span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">i</span>
<span class="n">method</span><span class="o">-</span><span class="n">frame</span><span class="p">(</span><span class="n">result</span><span class="o">=</span><span class="n">var_0</span><span class="p">):</span>
    <span class="n">needle</span> <span class="o">=</span> <span class="n">needle</span>
    <span class="n">haystack</span> <span class="o">=</span> <span class="n">haystack</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
    <span class="n">havoc</span> <span class="n">i</span>
    <span class="n">assume</span> <span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">-</span><span class="n">scope</span><span class="p">(</span><span class="n">inv</span><span class="o">=</span><span class="n">Inv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">needle</span><span class="p">,</span> <span class="n">haystack</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">i</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">var_0</span>
</pre></div>
</div>
</div>
</div>
<p>Symbolically executing this code uses sound loop-invariant based loop abstraction thanks to loop scopes, and produces an SET including nodes for all intermediate execution steps thanks to method frames.</p>
<div class="cell tag_full-width docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">find_program_with_func_decl_loop_scopes_method_frames</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
<span class="n">display_set</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/static_loops_74_0.svg" src="_images/static_loops_74_0.svg" /></div>
</div>
<div class="admonition-todo admonition">
<p class="admonition-title">TODO</p>
<p>Final words, maybe descriptions of related approaches to loop invariant reasoning (loop invariant inference, abstract interpretation, mention that in dynamic SE, pruning/search strategies are used)</p>
</div>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p id="id9"><dl class="citation">
<dt class="label" id="id178"><span class="brackets"><a class="fn-backref" href="#id3">ABB+16</a></span></dt>
<dd><p>Wolfgang Ahrendt, Bernhard Beckert, Richard Bubel, Reiner Hähnle, Peter H. Schmitt, and Mattias Ulbrich, editors. <em>Deductive Software Verification – The KeY Book</em>. Volume 10001 of LNCS. Springer, 2016. <a class="reference external" href="https://doi.org/10.1007/978-3-319-49812-6">doi:10.1007/978-3-319-49812-6</a>.</p>
</dd>
<dt class="label" id="id183"><span class="brackets"><a class="fn-backref" href="#id4">BCD+05</a></span></dt>
<dd><p>Mike Barnett, Bor-Yuh Evan Chang, Robert DeLine, Bart Jacobs, and K Rustan M Leino. Boogie: A Modular Reusable Verifier for Object-Oriented Programs. In <em>International Symposium on Formal Methods for Components and Objects</em>, 364–387. Springer, 2005.</p>
</dd>
<dt class="label" id="id217"><span class="brackets"><a class="fn-backref" href="#id2">DE82</a></span></dt>
<dd><p>R.B. Dannenberg and G.W. Ernst. Formal Program Verification Using Symbolic Execution. <em>IEEE Transactions on Software Engineering</em>, SE-8(1):43–52, 1982.</p>
</dd>
<dt class="label" id="id260"><span class="brackets"><a class="fn-backref" href="#id1">Hoa69</a></span></dt>
<dd><p>Charles Antony Richard Hoare. An Axiomatic Basis for Computer Programming. <em>Communications of the ACM</em>, 12(10):576–580, 1969.</p>
</dd>
<dt class="label" id="id71"><span class="brackets"><a class="fn-backref" href="#id8">Steinhofel20</a></span></dt>
<dd><p>Dominic Steinhöfel. <em>Abstract Execution: Automatically Proving Infinitely Many Programs</em>. PhD thesis, TU Darmstadt, Dept. of Computer Science, Darmstadt, Germany, 2020. URL: <a class="reference external" href="http://tuprints.ulb.tu-darmstadt.de/8540/">http://tuprints.ulb.tu-darmstadt.de/8540/</a>, <a class="reference external" href="https://doi.org/10.25534/tuprints-00008540">doi:10.25534/tuprints-00008540</a>.</p>
</dd>
<dt class="label" id="id34"><span class="brackets">SteinhofelW17</span><span class="fn-backref">(<a href="#id5">1</a>,<a href="#id6">2</a>)</span></dt>
<dd><p>Dominic Steinhöfel and Nathan Wasser. A New Invariant Rule for the Analysis of Loops with Non-standard Control Flows. In <em>Proc. 13th Intern. Conf on Integrated Formal Methods (IFM)</em>, 279–294. 2017. <a class="reference external" href="https://doi.org/10.1007/978-3-319-66845-1\_18">doi:10.1007/978-3-319-66845-1\_18</a>.</p>
</dd>
</dl>
</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="key"><span class="brackets"><a class="fn-backref" href="#id7">1</a></span></dt>
<dd><p><a class="reference external" href="https://www.key-project.org/">https://www.key-project.org/</a></p>
</dd>
</dl>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="transparent_function_execution.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Transparent Symbolic Execution of Function Calls</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="compositional.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Compositional Symbolic Execution</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Dominic Steinhöfel<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>