
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Parser and Interpreter for minipy &#8212; Symbolic Execution: Foundations, Techniques, Applications and Future Perspectives</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/page.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Foundations" href="foundations.html" />
    <link rel="prev" title="Introduction" href="intro.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Symbolic Execution: Foundations, Techniques, Applications and Future Perspectives</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Introduction
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Parser and Interpreter for minipy
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="foundations.html">
   Foundations
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="constraint_solving.html">
     Constraint Solving
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="semantics.html">
     Syntax and Semantics of Symbolic States
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="symbolic_interpreter.html">
     A Symbolic Interpreter and Correctness of Symbolic Transitions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="correctness.html">
     Correctness of Symbolic Transitions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="techniques.html">
   Techniques
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="transparent_function_execution.html">
     Transparent Symbolic Execution of Function Calls
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="static_loops.html">
     Loops in Static Symbolic Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="compositional.html">
     Compositional Symbolic Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="concolic.html">
     Concolic Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="stateexplosion.html">
     Tackling State Explosion
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="selective.html">
     Selective Symbolic Execution
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="applications.html">
   Applications
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="proving.html">
     Program Proving
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fuzzing.html">
     Symbolic Fuzzing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="debugging.html">
     Symbolic Debugging
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perspectives.html">
   Future Perspectives
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="conclusion.html">
   Conclusion
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/minipy.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/rindPHI/se-book-festschrift-rh"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/rindPHI/se-book-festschrift-rh/issues/new?title=Issue%20on%20page%20%2Fminipy.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parser">
   Parser
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interpreter">
   Interpreter
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="parser-and-interpreter-for-minipy">
<span id="minipy"></span><h1>Parser and Interpreter for minipy<a class="headerlink" href="#parser-and-interpreter-for-minipy" title="Permalink to this headline">¶</a></h1>
<p>We present and implement the symbolic execution techniques presented in this book for a statically typed, imperative,
proper subset of the Python language which we call <em>minipy</em>. The language supports Booleans, Integers, and (possibly
nested) tuples of Integers, first-order function definitions, assignments, and the statement types <code class="docutils literal notranslate"><span class="pre">pass</span></code>, <code class="docutils literal notranslate"><span class="pre">if</span></code>,
<code class="docutils literal notranslate"><span class="pre">while</span></code>, <code class="docutils literal notranslate"><span class="pre">try</span></code>-<code class="docutils literal notranslate"><span class="pre">except</span></code>, and <code class="docutils literal notranslate"><span class="pre">break</span></code> and <code class="docutils literal notranslate"><span class="pre">continue</span></code>. Examples of unsupported Python features are classes and objects,
strings, floats, nested function definitions and lambdas, comprehensions and generators, <code class="docutils literal notranslate"><span class="pre">for</span></code> loops, and the <code class="docutils literal notranslate"><span class="pre">raise</span></code>
statement. minipy comes with some standard builtin functions like <code class="docutils literal notranslate"><span class="pre">len</span></code>.</p>
<p>For example, the following is a valid minipy program:<a class="footnote-reference brackets" href="#while-else" id="id1">1</a></p>
<div class="cell tag_minipy docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">needle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">haystack</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">i</span>

<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let us inspect the results of this computation:<a class="footnote-reference brackets" href="#print-strings" id="id2">2</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;y = </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>x = 2
y = -1
</pre></div>
</div>
</div>
</div>
<p>The type annotations like <code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">int</span></code> for function arguments and <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">int</span></code> for return types of functions, which are optional
in Python (and not checked by the standard interpreter) are required in minipy. Since furthermore, it is not possible
to declare variables without assignments, minipy is statically typed. We also forbid assignments of non-matching types
to previously assigned variables, which is entirely possible in Python. This is to simplify the presentation of our
symbolic analyses.</p>
<p>Since minipy does not support classes and objects, <code class="docutils literal notranslate"><span class="pre">except</span></code> clauses are restricted to <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">ExceptionType</span></code> without an <code class="docutils literal notranslate"><span class="pre">as</span></code> clause:</p>
<div class="cell tag_minipy docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">//</span> <span class="n">y</span>
    <span class="k">except</span> <span class="ne">ArithmeticError</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<p>In the following, we define a parser and interpreter for minipy. While we could also use the Python interpreter, since minipy is a subset of Python, we define our own one to be able to easily extend it later with additional features. Furthermore, we will define symbolic and concolic interpreters based on the basic interpreter defined in this section.</p>
<div class="section" id="parser">
<h2>Parser<a class="headerlink" href="#parser" title="Permalink to this headline">¶</a></h2>
<p>Our parser is a Packrat parser <span id="id3">[<a class="reference internal" href="#id38"><span>For02</span></a>]</span> for a <a class="reference external" href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">Parsing Expression Grammar (PEG)</a> of minipy. For both the parser and interpreter, we use definitions from the <a class="reference external" href="https://www.fuzzingbook.org/">Fuzzing Book</a>. The grammar itself is inspired by the <a class="reference external" href="https://docs.python.org/3/reference/grammar.html">official Python 3 reference grammar</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">string</span>
<span class="kn">from</span> <span class="nn">fuzzingbook.Grammars</span> <span class="kn">import</span> <span class="n">srange</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">MINIPY_GRAMMAR</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;stmts&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;stmts&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;stmt&gt;&lt;NEWLINE&gt;&lt;stmts&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;stmt&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;stmt&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;compound_stmt&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;simple_stmt&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;simple_stmt&gt;&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;pass&quot;</span><span class="p">,</span>
        <span class="s2">&quot;break&quot;</span><span class="p">,</span>
        <span class="s2">&quot;continue&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;return_stmt&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;assert_stmt&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;assignment&gt;&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s2">&quot;&lt;compound_stmt&gt;&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;&lt;function_def&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;try_stmt&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;if_stmt&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;while_stmt&gt;&quot;</span>
    <span class="p">],</span>
    <span class="s2">&quot;&lt;assignment&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;NAME&gt; = &lt;expression&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;return_stmt&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;return &lt;expression&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;assert_stmt&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;assert &lt;expression&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;if_stmt&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;if &lt;expression&gt;:&lt;block&gt;&lt;maybe_else_block&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;maybe_else_block&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;NEWLINE&gt;else:&lt;block&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;while_stmt&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;while &lt;expression&gt;:&lt;block&gt;&lt;maybe_else_block&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;try_stmt&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;try:&lt;block&gt;&lt;except_block&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;function_def&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;def &lt;NAME&gt;(&lt;params&gt;) -&gt; &lt;type&gt;:&lt;block&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;except_block&gt;&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;&lt;NEWLINE&gt;except &lt;NAME&gt;:&lt;block&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;NEWLINE&gt;except:&lt;block&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;NEWLINE&gt;&lt;INDENT&gt;&lt;stmts&gt;&lt;DEDENT&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;params&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;param&gt;, &lt;params&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;param&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;param&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;NAME&gt;: &lt;type&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;type&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="s2">&quot;tuple&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;conjunction&gt;&lt;or_conjunctions&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;or_conjunctions&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;or_conjunction&gt;&lt;or_conjunctions&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;or_conjunction&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot; or &lt;conjunction&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;conjunction&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;inversion&gt;&lt;and_inversions&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;and_inversions&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;and_inversion&gt;&lt;and_inversions&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;and_inversion&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot; and &lt;inversion&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;inversion&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;not &lt;inversion&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;comparison&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;(&lt;expression&gt;)&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;comparison&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;sum&gt;&lt;maybe_compare&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;maybe_compare&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot; &lt;compare_op&gt; &lt;sum&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;compare_op&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;==&quot;</span><span class="p">,</span> <span class="s2">&quot;!=&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;sum&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;term&gt; &lt;ssym&gt; &lt;sum&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;ssym&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;&lt;factor&gt; &lt;tsym&gt; &lt;term&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;factor&gt; &lt;tsym&gt; (&lt;sum&gt;)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;(&lt;sum&gt;) &lt;tsym&gt; &lt;factor&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;(&lt;sum&gt;) &lt;tsym&gt; (&lt;sum&gt;)&quot;</span><span class="p">,</span>

        <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s2">&quot;&lt;tsym&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;//&quot;</span><span class="p">,</span> <span class="s2">&quot;%&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;+&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;-&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;primary&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;primary&gt;&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;&lt;atom&gt;[&lt;expression&gt;]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;NAME&gt;(&lt;args&gt;)[&lt;expression&gt;]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;NAME&gt;(&lt;args&gt;)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;&lt;atom&gt;&quot;</span>
    <span class="p">],</span>
    <span class="s2">&quot;&lt;args&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;expression&gt;, &lt;args&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;atom&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;True&quot;</span><span class="p">,</span> <span class="s2">&quot;False&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;tuple&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;NUMBER&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;tuple&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;tuple()&quot;</span><span class="p">,</span> <span class="s2">&quot;(&lt;expression&gt;, &lt;expression_list&gt;)&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;expression_list&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;expression&gt;, &lt;expression_list&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;NEWLINE&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;NUMBER&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;DIGIT&gt;&lt;NUMBER&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;DIGIT&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;DIGIT&gt;&quot;</span><span class="p">:</span> <span class="n">srange</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">digits</span><span class="p">),</span>
    <span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;INIT_CHAR&gt;&lt;IDCHARS&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;INIT_CHAR&gt;&quot;</span><span class="p">:</span> <span class="n">srange</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="p">),</span>
    <span class="s2">&quot;&lt;IDCHARS&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;IDCHAR&gt;&lt;IDCHARS&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;IDCHAR&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;IDCHAR&gt;&quot;</span><span class="p">:</span> <span class="n">srange</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="p">),</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>To keep the grammar simple, it is quite restrictive with respect to whitespace. For example, no empty lines between statements are allowed, and tuple definitions must adhere to the form <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">)</span></code> (including the final <code class="docutils literal notranslate"><span class="pre">,</span></code> and space).</p>
<p>The interpretation of the <code class="docutils literal notranslate"><span class="pre">&lt;INDENT&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;DEDENT&gt;</span></code> nonterminals is such that they increase / decrease the indentation level; <code class="docutils literal notranslate"><span class="pre">&lt;INDENT&gt;</span></code> matches for additional spaces, <code class="docutils literal notranslate"><span class="pre">&lt;DEDENT&gt;</span></code> matches the empty string. To account for these special nonterminals, we slightly extended the PEG parser from the Fuzzing Book.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
<span class="kn">from</span> <span class="nn">fuzzingbook.Parser</span> <span class="kn">import</span> <span class="n">PEGParser</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PythonPEGParser</span><span class="p">(</span><span class="n">PEGParser</span><span class="p">):</span>
    <span class="n">INDENT_SIZE</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">unify_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">at</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;unify_rule: </span><span class="si">%s</span><span class="s1"> with </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">rule</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">at</span><span class="p">:])))</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">rule</span><span class="p">:</span>
            <span class="n">at</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unify_key</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="p">,</span> <span class="n">at</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">at</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">at</span><span class="p">,</span> <span class="n">results</span>

    <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">unify_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="n">at</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># NOTE: Passing indent as a parameter is necessary for sound caching.</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;&lt;INDENT&gt;&quot;</span><span class="p">:</span>
            <span class="n">new_indent</span> <span class="o">=</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">PythonPEGParser</span><span class="o">.</span><span class="n">INDENT_SIZE</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">at</span><span class="p">:]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">new_indent</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Increasing indent to </span><span class="si">{</span><span class="n">new_indent</span><span class="si">}</span><span class="s2"> spaces.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">at</span> <span class="o">+</span> <span class="n">new_indent</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">new_indent</span><span class="p">),</span> <span class="p">[])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">at</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;&lt;DEDENT&gt;&quot;</span><span class="p">:</span>
            <span class="n">new_indent</span> <span class="o">=</span> <span class="p">(</span><span class="n">indent</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">PythonPEGParser</span><span class="o">.</span><span class="n">INDENT_SIZE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Decreasing indent to </span><span class="si">{</span><span class="n">new_indent</span><span class="si">}</span><span class="s2"> spaces.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">at</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">at</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">text</span><span class="p">[</span><span class="n">at</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">at</span><span class="p">:]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">*</span> <span class="n">PythonPEGParser</span><span class="o">.</span><span class="n">INDENT_SIZE</span><span class="p">)):</span>
                <span class="n">at</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">*</span> <span class="n">PythonPEGParser</span><span class="o">.</span><span class="n">INDENT_SIZE</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">at</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">at</span><span class="p">:]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">at</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">at</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgrammar</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="n">to</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unify_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">at</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">to</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
<p>Running the parser produces a parse tree:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fuzzingbook.GrammarFuzzer</span> <span class="kn">import</span> <span class="n">display_tree</span>
<span class="kn">import</span> <span class="nn">graphviz</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">example_program</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;x = a // b</span>
<span class="s2">return x&quot;&quot;&quot;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">PythonPEGParser</span><span class="p">(</span><span class="n">MINIPY_GRAMMAR</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">example_program</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/minipy_17_0.svg" src="_images/minipy_17_0.svg" /></div>
</div>
<p>One problem with our minipy grammar is that it is quite restrictive when it comes to whitespace. For instance, it is not allowed to add empty lines between statements. Also comments are unsupported. Instead of making the grammar more complex, we use a simple helper function to remove comments and whitespace from raw text:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">strip_comments_and_whitespace</span><span class="p">(</span><span class="n">inp</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">inp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="n">comment_start</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comment_start</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="n">comment_start</span><span class="p">]</span>

        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>  <span class="c1"># Generally must not remove leading whitespace, but here we check for empty lines</span>
            <span class="k">continue</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">example_program</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;x = a // b  # A division statement</span>
<span class="s2"># An empty line:</span>

<span class="s2">return x # Now we return&quot;&quot;&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">example_program</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>x = a // b  # A division statement
# An empty line:

return x # Now we return
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fuzzingbook.ExpectError</span> <span class="kn">import</span> <span class="n">ExpectError</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">example_program</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Traceback (most recent call last):
  File &quot;/tmp/ipykernel_1384/3620741631.py&quot;, line 2, in &lt;module&gt;
    tree = parser.parse(example_program)[0]
  File &quot;/opt/conda/lib/python3.9/site-packages/fuzzingbook/Parser.py&quot;, line 503, in parse
    raise SyntaxError(&quot;at &quot; + repr(text[cursor:]))
SyntaxError: at &#39;  # A division statement\n# An empty line:\n\nreturn x # Now we return&#39; (expected)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">strip_comments_and_whitespace</span><span class="p">(</span><span class="n">example_program</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/minipy_23_0.svg" src="_images/minipy_23_0.svg" /></div>
</div>
<p>For not having to deal with raw parse trees as output by the generic packrat parser, we translate these into an abstract syntax tree (AST) with specialized classes for each language concept. Our base class is <code class="docutils literal notranslate"><span class="pre">ASTNode</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Callable</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ParseTree</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;ParseTree&#39;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ASTNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span>

    <span class="k">def</span> <span class="nf">to_str_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;&lt;type&gt;&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">}</span> <span class="o">|</span>
                <span class="p">{</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
                        <span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span>
                        <span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">to_str_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span>
                        <span class="s2">&quot;None&quot;</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="n">value</span><span class="o">.</span><span class="n">to_str_dict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
        <span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;ASTNode&#39;</span><span class="p">],</span> <span class="s1">&#39;ASTNode&#39;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;ASTNode&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_str_dict</span><span class="p">(),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">transform</span></code>, following the Visitor pattern, can be used for AST transformations (we use this, for example, in <a class="reference internal" href="transparent_function_execution.html#techniques-transparent-function-execution"><span class="std std-ref">Transparent Symbolic Execution of Function Calls</span></a>).</p>
<p>The specific AST class for an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement looks as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IfStmt</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">guard</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span><span class="p">,</span>
            <span class="n">then_block</span><span class="p">:</span> <span class="n">Block</span><span class="p">,</span>
            <span class="n">else_block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Block</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;if </span><span class="si">{</span><span class="n">guard</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="p">(</span><span class="n">then_block</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span>
            <span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">else_block</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">else:</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="p">(</span><span class="n">else_block</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">guard</span> <span class="o">=</span> <span class="n">guard</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">then_block</span> <span class="o">=</span> <span class="n">then_block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">else_block</span> <span class="o">=</span> <span class="n">else_block</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">IfStmt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">guard</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">then_block</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_block</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>
</pre></div>
</div>
<p>To inspect the complete definitions for all AST node classes, press the toggle on the right below.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>


<span class="k">def</span> <span class="nf">indent</span><span class="p">(</span><span class="n">inp</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">by</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">by</span> <span class="o">+</span> <span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">Stmts</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ASTNode</span><span class="p">]):</span>
        <span class="n">stmts_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">stmts</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">Stmts</span><span class="p">):</span>
                <span class="n">stmt</span><span class="p">:</span> <span class="n">Stmts</span>
                <span class="n">stmts_</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">stmts</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stmts_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">stmt</span><span class="o">.</span><span class="n">code</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">stmts_</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmts</span> <span class="o">=</span> <span class="n">stmts_</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Stmts</span><span class="p">([</span><span class="n">stmt</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmts</span><span class="p">]))</span>


<span class="k">class</span> <span class="nc">Pass</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;pass&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BreakStmt</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;break&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ContinueStmt</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;continue&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">HaltStmt</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;halt&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ReturnStmt</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;return &quot;</span> <span class="o">+</span> <span class="n">expression</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">ReturnStmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Havoc</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;havoc &quot;</span> <span class="o">+</span> <span class="n">variable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Assume</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;assume &quot;</span> <span class="o">+</span> <span class="n">expression</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Assume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Assert</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;assert &quot;</span> <span class="o">+</span> <span class="n">expression</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Assignment</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lhs</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">expression</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Block</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ASTNode</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">stmt</span><span class="o">.</span><span class="n">code</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">stmts</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmts</span> <span class="o">=</span> <span class="n">stmts</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Block</span><span class="p">([</span><span class="n">stmt</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmts</span><span class="p">]))</span>


<span class="k">class</span> <span class="nc">FunctionDef</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Param&#39;</span><span class="p">],</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;def </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">(&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">param</span><span class="o">.</span><span class="n">code</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">])</span> <span class="o">+</span>
            <span class="sa">f</span><span class="s2">&quot;) -&gt; </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">FunctionDef</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Param</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TryStmt</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Block</span><span class="p">,</span> <span class="n">except_block</span><span class="p">:</span> <span class="n">Block</span><span class="p">,</span>
                 <span class="n">exc_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;try:&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exc_type</span> <span class="o">=</span> <span class="n">exc_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">except_block</span> <span class="o">=</span> <span class="n">except_block</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">TryStmt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">except_block</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">exc_type</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">MethodFrame</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="s1">&#39;NameAtom&#39;</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;method-frame(result=</span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">):</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">MethodFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">IfStmt</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">guard</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span><span class="p">,</span>
            <span class="n">then_block</span><span class="p">:</span> <span class="n">Block</span><span class="p">,</span>
            <span class="n">else_block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Block</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;if </span><span class="si">{</span><span class="n">guard</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="p">(</span><span class="n">then_block</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span>
            <span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">else_block</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">else:</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="p">(</span><span class="n">else_block</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">guard</span> <span class="o">=</span> <span class="n">guard</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">then_block</span> <span class="o">=</span> <span class="n">then_block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">else_block</span> <span class="o">=</span> <span class="n">else_block</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">IfStmt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">guard</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">then_block</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_block</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">WhileStmt</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">guard</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="n">Block</span><span class="p">,</span> <span class="n">else_block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Block</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;while </span><span class="si">{</span><span class="n">guard</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span>
            <span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">else_block</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">else:</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="p">(</span><span class="n">else_block</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;    &#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">guard</span> <span class="o">=</span> <span class="n">guard</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">else_block</span> <span class="o">=</span> <span class="n">else_block</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">WhileStmt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">guard</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_block</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Expression</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Inversion</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">argument</span><span class="p">:</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not </span><span class="si">{</span><span class="n">argument</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inversion</span> <span class="o">=</span> <span class="n">argument</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Inversion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inversion</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Conjunction</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expression</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s2">&quot; and &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">inversions</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inversions</span> <span class="o">=</span> <span class="n">inversions</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Conjunction</span><span class="p">([</span><span class="n">inversion</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span> <span class="k">for</span> <span class="n">inversion</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversions</span><span class="p">]))</span>


<span class="k">class</span> <span class="nc">Disjunction</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conjunctions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expression</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s2">&quot; or &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">conjunctions</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conjunctions</span> <span class="o">=</span> <span class="n">conjunctions</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Disjunction</span><span class="p">([</span><span class="n">conjunction</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span> <span class="k">for</span> <span class="n">conjunction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conjunctions</span><span class="p">]))</span>


<span class="k">class</span> <span class="nc">Comparison</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">left</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">right</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Comparison</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Sum</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">left</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">right</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Term</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">left</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">right</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Term</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Factor</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symb</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">factor</span><span class="p">:</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">symb</span><span class="si">}{</span><span class="n">factor</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symb</span> <span class="o">=</span> <span class="n">symb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">Factor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">TupleAccess</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">expression</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="n">atom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">TupleAccess</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">FunctionCall</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expression</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">(&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">arg</span><span class="o">.</span><span class="n">code</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">FunctionCall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]))</span>


<span class="k">class</span> <span class="nc">BooleanAtom</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IntAtom</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NameAtom</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TupleNode</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elems</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expression</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;tuple()&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">elems</span> <span class="k">else</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">elem</span><span class="o">.</span><span class="n">code</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;, )&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">elems</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">(</span><span class="n">TupleNode</span><span class="p">([</span><span class="n">elem</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
<p>For conveniently defining the AST converter, we define a function <code class="docutils literal notranslate"><span class="pre">match</span></code> for matching parse tree elements to a tuple of expected nonterminals. <code class="docutils literal notranslate"><span class="pre">match</span></code> will return <code class="docutils literal notranslate"><span class="pre">None</span></code> if the tree does not match the expected structure; otherwise, it returns a tuple of the same length as the input nonterminal tuple containing the instantiations of these nonterminals. Once a searched-for nonterminal has been found, <code class="docutils literal notranslate"><span class="pre">match</span></code> continues with the next path in the tree, using the <code class="docutils literal notranslate"><span class="pre">next_path</span></code> function also shown below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Path</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">symbols</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
          <span class="n">tree</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">,</span>
          <span class="n">path</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="p">(),</span>
          <span class="n">result</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ParseTree</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">())</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ParseTree</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="n">next_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">node</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">get_subtree</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&lt;INDENT&gt;&quot;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">children</span><span class="p">),)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="n">next_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">next_p</span> <span class="o">=</span> <span class="n">next_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">next_p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">match</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tree</span><span class="p">,</span> <span class="n">next_p</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">next_p</span> <span class="o">=</span> <span class="n">next_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">match</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">next_p</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">match</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">next_path</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Path</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns the next path in the tree; does not proceed towards leaves!&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">node</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">get_subtree</span><span class="p">(</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tree</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">next_path</span><span class="p">(</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>A <em>path</em> is a tuple of integers pointing to a particular subtree. Consider the following tree:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="p">[]),</span> <span class="p">(</span><span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="p">[])]),</span> <span class="p">(</span><span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="p">[])])</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/minipy_37_0.svg" src="_images/minipy_37_0.svg" /></div>
</div>
<p>Then the path <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1)</span></code> points to the subtree <code class="docutils literal notranslate"><span class="pre">(&quot;4&quot;,</span> <span class="pre">[])</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_subtree</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParseTree</span><span class="p">:</span>
    <span class="n">node</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">tree</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tree</span>

    <span class="k">return</span> <span class="n">get_subtree</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">children</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display_tree</span><span class="p">(</span><span class="n">get_subtree</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/minipy_40_0.svg" src="_images/minipy_40_0.svg" /></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display_tree</span><span class="p">(</span><span class="n">get_subtree</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/minipy_41_0.svg" src="_images/minipy_41_0.svg" /></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display_tree</span><span class="p">(</span><span class="n">get_subtree</span><span class="p">((),</span> <span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/minipy_42_0.svg" src="_images/minipy_42_0.svg" /></div>
</div>
<p>Let’s try out the <code class="docutils literal notranslate"><span class="pre">match</span></code> function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">inp</span> <span class="o">=</span> <span class="s2">&quot;my_fun(17)[-2]&quot;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">PythonPEGParser</span><span class="p">(</span><span class="n">MINIPY_GRAMMAR</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">parse_on</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="s2">&quot;&lt;primary&gt;&quot;</span><span class="p">))</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/minipy_44_0.svg" src="_images/minipy_44_0.svg" /></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;atom&gt;&quot;</span><span class="p">,),</span> <span class="n">tree</span><span class="p">)</span>
<span class="n">m_res</span> <span class="ow">is</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fuzzingbook.GrammarFuzzer</span> <span class="kn">import</span> <span class="n">tree_to_string</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;args&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)[&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">),</span> <span class="n">tree</span><span class="p">)</span>
<span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">,</span> <span class="n">m_res</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;my_fun&#39;, &#39;(&#39;, &#39;17&#39;, &#39;)[&#39;, &#39;-2&#39;, &#39;]&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">((</span><span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;args&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)[&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">,</span> <span class="n">m_res</span><span class="p">))))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;NAME&gt;&#39;: &#39;my_fun&#39;,
 &#39;(&#39;: &#39;(&#39;,
 &#39;&lt;args&gt;&#39;: &#39;17&#39;,
 &#39;)[&#39;: &#39;)[&#39;,
 &#39;&lt;expression&gt;&#39;: &#39;-2&#39;,
 &#39;]&#39;: &#39;]&#39;}
</pre></div>
</div>
</div>
</div>
<p>The class <code class="docutils literal notranslate"><span class="pre">ASTConverter</span></code> uses the match function to dissect parse trees. For example, here is the code processing a <code class="docutils literal notranslate"><span class="pre">return</span></code> statement:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ASTConverter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">transform_return_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;return &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ReturnStmt</span><span class="p">(</span><span class="n">eval_expr_result</span><span class="p">)</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>The top-level functions are <code class="docutils literal notranslate"><span class="pre">transform_top</span></code> for statements and <code class="docutils literal notranslate"><span class="pre">transform_expr_top</span></code> for expressions. They look up the nonterminal type of a parse tree node in a dictionary mapping these to specific transformations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ASTConverter</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ParseTree</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_start</span><span class="p">,</span>
            <span class="s2">&quot;&lt;stmts&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_stmts</span><span class="p">,</span>
            <span class="s2">&quot;&lt;stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_stmt</span><span class="p">,</span>
            <span class="s2">&quot;&lt;simple_stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_simple_stmt</span><span class="p">,</span>
            <span class="s2">&quot;&lt;compound_stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_compound_stmt</span><span class="p">,</span>
            <span class="s2">&quot;pass&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_pass</span><span class="p">,</span>
            <span class="c1"># ...</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ParseTree</span><span class="p">],</span> <span class="n">Expression</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">,</span>
            <span class="s2">&quot;&lt;conjunction&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_conjunction</span><span class="p">,</span>
            <span class="s2">&quot;&lt;inversion&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inversion</span><span class="p">,</span>
            <span class="c1"># ...</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">transform_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stmt</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="n">node</span><span class="p">](</span><span class="n">stmt</span><span class="p">)</span>

        <span class="k">assert</span> <span class="kc">False</span>
            
    <span class="k">def</span> <span class="nf">transform_expr_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">[</span><span class="n">node</span><span class="p">](</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">assert</span> <span class="kc">False</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>The full code for the <code class="docutils literal notranslate"><span class="pre">ASTConverter</span></code> class is given below (click the toggle).</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ASTConverter</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ParseTree</span><span class="p">],</span> <span class="n">ASTNode</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_start</span><span class="p">,</span>
            <span class="s2">&quot;&lt;stmts&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_stmts</span><span class="p">,</span>
            <span class="s2">&quot;&lt;stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_stmt</span><span class="p">,</span>
            <span class="s2">&quot;&lt;simple_stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_simple_stmt</span><span class="p">,</span>
            <span class="s2">&quot;&lt;compound_stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_compound_stmt</span><span class="p">,</span>
            <span class="s2">&quot;pass&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_pass</span><span class="p">,</span>
            <span class="s2">&quot;break&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_break</span><span class="p">,</span>
            <span class="s2">&quot;continue&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_continue</span><span class="p">,</span>
            <span class="s2">&quot;halt&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_halt</span><span class="p">,</span>
            <span class="s2">&quot;&lt;return_stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_return_stmt</span><span class="p">,</span>
            <span class="s2">&quot;&lt;assert_stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_assert_stmt</span><span class="p">,</span>
            <span class="s2">&quot;&lt;assignment&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_assignment</span><span class="p">,</span>
            <span class="s2">&quot;&lt;function_def&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_function_def</span><span class="p">,</span>
            <span class="s2">&quot;&lt;try_stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_try_stmt</span><span class="p">,</span>
            <span class="s2">&quot;&lt;while_stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_while_stmt</span><span class="p">,</span>
            <span class="s2">&quot;&lt;if_stmt&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_if_stmt</span><span class="p">,</span>
            <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ParseTree</span><span class="p">],</span> <span class="n">Expression</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">,</span>
            <span class="s2">&quot;&lt;conjunction&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_conjunction</span><span class="p">,</span>
            <span class="s2">&quot;&lt;inversion&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inversion</span><span class="p">,</span>
            <span class="s2">&quot;&lt;comparison&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_comparison</span><span class="p">,</span>
            <span class="s2">&quot;&lt;sum&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_sum</span><span class="p">,</span>
            <span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_term</span><span class="p">,</span>
            <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_factor</span><span class="p">,</span>
            <span class="s2">&quot;&lt;primary&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_primary</span><span class="p">,</span>
            <span class="s2">&quot;&lt;atom&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_atom</span><span class="p">,</span>
            <span class="s2">&quot;&lt;tuple&gt;&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_tuple</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">transform_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stmt</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="n">node</span><span class="p">](</span><span class="n">stmt</span><span class="p">)</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">transform_expr_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">[</span><span class="n">node</span><span class="p">](</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">transform_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmts</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ParseTree</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ASTNode</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_top</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">stmts</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">transform_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;stmts&gt;&quot;</span><span class="p">,),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_top</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">transform_stmts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Stmts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;stmt&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;NEWLINE&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;stmts&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Stmts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_sequence</span><span class="p">((</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>

        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;stmt&gt;&quot;</span><span class="p">,),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Stmts</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_top</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>

    <span class="k">def</span> <span class="nf">transform_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_top</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">transform_simple_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_top</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">transform_compound_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_top</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">transform_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Pass</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">transform_break</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">BreakStmt</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">transform_continue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ContinueStmt</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">transform_halt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">HaltStmt</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">transform_return_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;return &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ReturnStmt</span><span class="p">(</span><span class="n">eval_expr_result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_assert_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;assert &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Assert</span><span class="p">(</span><span class="n">eval_expr_result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot; = &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expr_top</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Assignment</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">eval_expr_result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_function_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FunctionDef</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;def &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;params&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;) -&gt; &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;type&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">,),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">f_name</span> <span class="o">=</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_block</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">FunctionDef</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Param</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;: &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;type&gt;&quot;</span><span class="p">,),</span> <span class="n">param</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Param</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">transform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Param</span><span class="p">]:</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Param</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;param&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;params&gt;&quot;</span><span class="p">),</span> <span class="n">params</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_param</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;param&gt;&quot;</span><span class="p">,),</span> <span class="n">params</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_param</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">transform_try_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TryStmt</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;try:&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;except_block&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_block</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sub_m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NEWLINE&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;except &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">):</span>
            <span class="n">except_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_block</span><span class="p">(</span><span class="n">sub_m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">TryStmt</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">except_block</span><span class="p">,</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">sub_m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NEWLINE&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;except:&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">):</span>
            <span class="n">except_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_block</span><span class="p">(</span><span class="n">sub_m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">TryStmt</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">except_block</span><span class="p">,</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">sub_m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="k">assert</span> <span class="kc">False</span>
        
    <span class="k">def</span> <span class="nf">transform_if_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IfStmt</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;if &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;maybe_else_block&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expr_top</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">sub_m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NEWLINE&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;else:&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">),</span> <span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sub_m_res</span><span class="p">:</span>
            <span class="n">else_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_block</span><span class="p">(</span><span class="n">sub_m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">IfStmt</span><span class="p">(</span><span class="n">eval_expr_result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_block</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">else_block</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IfStmt</span><span class="p">(</span><span class="n">eval_expr_result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_block</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">transform_while_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WhileStmt</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;while &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;maybe_else_block&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">guard</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_block</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">sub_m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NEWLINE&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;else:&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">),</span> <span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sub_m_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">WhileStmt</span><span class="p">(</span><span class="n">guard</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">else_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_block</span><span class="p">(</span><span class="n">sub_m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">WhileStmt</span><span class="p">(</span><span class="n">guard</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">else_block</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Block</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NEWLINE&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;&lt;INDENT&gt;&#39;</span><span class="p">,</span> <span class="s2">&quot;&lt;stmts&gt;&quot;</span><span class="p">),</span> <span class="n">stmt</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_stmts</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">stmts</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;simple_stmt&gt;&quot;</span><span class="p">,),</span> <span class="n">stmt</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Block</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_simple_stmt</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">transform_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;conjunction&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;or_conjunctions&gt;&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">conj_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_conjunction</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conj_eval</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">conj_eval</span><span class="p">]</span>
        <span class="n">remaining_tree</span> <span class="o">=</span> <span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot; or &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;conjunction&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;or_conjunctions&gt;&quot;</span><span class="p">),</span> <span class="n">remaining_tree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">remaining_tree</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
                <span class="k">break</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_conjunction</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">remaining_tree</span> <span class="o">=</span> <span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Disjunction</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_conjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;inversion&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;and_inversions&gt;&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">inv_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inversion</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inv_eval</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">inv_eval</span><span class="p">]</span>
        <span class="n">remaining_tree</span> <span class="o">=</span> <span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot; and &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;inversion&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;and_inversions&gt;&quot;</span><span class="p">),</span> <span class="n">remaining_tree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">remaining_tree</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
                <span class="k">break</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_inversion</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">remaining_tree</span> <span class="o">=</span> <span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Conjunction</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_inversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;not &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;inversion&gt;&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Inversion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_inversion</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;comparison&gt;&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_comparison</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">transform_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;sum&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;maybe_compare&gt;&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">eval_sum_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_sum</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">sub_m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;compare_op&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;sum&gt;&quot;</span><span class="p">),</span> <span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sub_m_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
            <span class="k">return</span> <span class="n">eval_sum_result</span>

        <span class="n">eval_sum_2_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_sum</span><span class="p">(</span><span class="n">sub_m_res</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">Comparison</span><span class="p">(</span><span class="n">eval_sum_result</span><span class="p">,</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">sub_m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">eval_sum_2_result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;ssym&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;sum&gt;&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="n">eval_res_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_term</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">eval_res_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_sum</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="n">eval_res_1</span><span class="p">,</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">eval_res_2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_term</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">transform_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;tsym&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="n">eval_res_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_factor</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">eval_res_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_term</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">eval_res_1</span><span class="p">,</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">eval_res_2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;tsym&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot; (&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;sum&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="n">eval_res_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_factor</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">eval_res_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_sum</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">eval_res_1</span><span class="p">,</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">eval_res_2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;sum&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;) &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;tsym&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="n">eval_res_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_sum</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">eval_res_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_factor</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">eval_res_1</span><span class="p">,</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">eval_res_2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;sum&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;) &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;tsym&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot; (&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;sum&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="n">eval_res_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_sum</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">eval_res_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_sum</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">eval_res_1</span><span class="p">,</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">eval_res_2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_factor</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">transform_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Factor</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_factor</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Factor</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_factor</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;primary&gt;&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_primary</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">transform_primary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;atom&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="n">eval_atom_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_atom</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">eval_expr_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">TupleAccess</span><span class="p">(</span><span class="n">eval_atom_res</span><span class="p">,</span> <span class="n">eval_expr_res</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;args&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)[&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;tuple&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_primary</span><span class="p">(</span>
                    <span class="p">(</span><span class="s2">&quot;primary&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;&lt;atom&gt;&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;&lt;tuple&gt;&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;tuple()&quot;</span><span class="p">,</span> <span class="p">[])])]),</span> <span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;]&quot;</span><span class="p">]))</span>

            <span class="n">eval_args_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_args</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">eval_expr_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">TupleAccess</span><span class="p">(</span><span class="n">FunctionCall</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">eval_args_res</span><span class="p">),</span> <span class="n">eval_expr_res</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;args&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;tuple&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_primary</span><span class="p">(</span>
                    <span class="p">(</span><span class="s2">&quot;primary&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;&lt;atom&gt;&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;&lt;tuple&gt;&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;tuple()&quot;</span><span class="p">,</span> <span class="p">[])])])]))</span>

            <span class="n">eval_args_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_args</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">FunctionCall</span><span class="p">(</span><span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">eval_args_res</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;atom&gt;&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_atom</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">transform_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Expression</span><span class="p">]:</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;args&gt;&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_args</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">transform_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="n">atom_str</span> <span class="o">=</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m_res</span> <span class="o">:=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;tuple&gt;&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_tuple</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;True&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BooleanAtom</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;False&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BooleanAtom</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NUMBER&gt;&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">IntAtom</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">atom_str</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;NAME&gt;&quot;</span><span class="p">,),</span> <span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">NameAtom</span><span class="p">(</span><span class="n">atom_str</span><span class="p">)</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">transform_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;tuple()&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TupleNode</span><span class="p">([])</span>

        <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression_list&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">expr_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TupleNode</span><span class="p">([</span><span class="n">expr_eval</span><span class="p">])</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr_eval</span><span class="p">]</span>
        <span class="n">remaining_tree</span> <span class="o">=</span> <span class="n">m_res</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">m_res</span> <span class="o">=</span> <span class="n">match</span><span class="p">((</span><span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;expression_list&gt;&quot;</span><span class="p">),</span> <span class="n">remaining_tree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">tree_to_string</span><span class="p">(</span><span class="n">remaining_tree</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
                <span class="k">break</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_expression</span><span class="p">(</span><span class="n">m_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">remaining_tree</span> <span class="o">=</span> <span class="n">m_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">TupleNode</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We define some convenience functions for parsing a string into a statement or expression, optionally starting form a specific nonterminal.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">inp</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">strip_comments_and_whitespace</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">PythonPEGParser</span><span class="p">(</span><span class="n">MINIPY_GRAMMAR</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">inp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ASTConverter</span><span class="p">()</span><span class="o">.</span><span class="n">transform_top</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_on</span><span class="p">(</span><span class="n">inp</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">nonterminal</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">strip_comments_and_whitespace</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">PythonPEGParser</span><span class="p">(</span><span class="n">MINIPY_GRAMMAR</span><span class="p">)</span><span class="o">.</span><span class="n">parse_on</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">nonterminal</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ASTConverter</span><span class="p">()</span><span class="o">.</span><span class="n">transform_top</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_expr</span><span class="p">(</span><span class="n">inp</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">strip_comments_and_whitespace</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">PythonPEGParser</span><span class="p">(</span><span class="n">MINIPY_GRAMMAR</span><span class="p">)</span><span class="o">.</span><span class="n">parse_on</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="s2">&quot;&lt;expression&gt;&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ASTConverter</span><span class="p">()</span><span class="o">.</span><span class="n">transform_expr_top</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_expr_on</span><span class="p">(</span><span class="n">inp</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">nonterminal</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">strip_comments_and_whitespace</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">PythonPEGParser</span><span class="p">(</span><span class="n">MINIPY_GRAMMAR</span><span class="p">)</span><span class="o">.</span><span class="n">parse_on</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">nonterminal</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ASTConverter</span><span class="p">()</span><span class="o">.</span><span class="n">transform_expr_top</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ast</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">example_program</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AST: </span><span class="si">{</span><span class="n">ast</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Code:</span><span class="se">\n</span><span class="si">{</span><span class="n">ast</span><span class="o">.</span><span class="n">code</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LHS of assignment: </span><span class="si">{</span><span class="n">ast</span><span class="o">.</span><span class="n">stmts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lhs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AST: {
  &quot;&lt;type&gt;&quot;: &quot;Stmts&quot;,
  &quot;code&quot;: &quot;x = (a // b)\nreturn x&quot;,
  &quot;stmts&quot;: [
    {
      &quot;&lt;type&gt;&quot;: &quot;Assignment&quot;,
      &quot;code&quot;: &quot;x = (a // b)&quot;,
      &quot;lhs&quot;: &quot;x&quot;,
      &quot;expression&quot;: {
        &quot;&lt;type&gt;&quot;: &quot;Term&quot;,
        &quot;code&quot;: &quot;(a // b)&quot;,
        &quot;left&quot;: {
          &quot;&lt;type&gt;&quot;: &quot;NameAtom&quot;,
          &quot;code&quot;: &quot;a&quot;,
          &quot;name&quot;: &quot;a&quot;
        },
        &quot;op&quot;: &quot;//&quot;,
        &quot;right&quot;: {
          &quot;&lt;type&gt;&quot;: &quot;NameAtom&quot;,
          &quot;code&quot;: &quot;b&quot;,
          &quot;name&quot;: &quot;b&quot;
        }
      }
    },
    {
      &quot;&lt;type&gt;&quot;: &quot;ReturnStmt&quot;,
      &quot;code&quot;: &quot;return x&quot;,
      &quot;expression&quot;: {
        &quot;&lt;type&gt;&quot;: &quot;NameAtom&quot;,
        &quot;code&quot;: &quot;x&quot;,
        &quot;name&quot;: &quot;x&quot;
      }
    }
  ]
}

Code:
x = (a // b)
return x

LHS of assignment: x
</pre></div>
</div>
</div>
</div>
<p>Subsequently, we define an interpreter for processing minipy parse trees.</p>
</div>
<div class="section" id="interpreter">
<h2>Interpreter<a class="headerlink" href="#interpreter" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition">
<p class="admonition-title">TODO</p>
<p>Refer to the Python language specification.</p>
</div>
<p>The Python type <code class="docutils literal notranslate"><span class="pre">ValueType</span></code> is the union type of all types to which minipy expressions can evaluate.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">NestedIntTuple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;NestedIntTuple&#39;</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
<span class="n">ValueType</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NestedIntTuple</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>We also need syntactical types for minipy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Type</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default_literal</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_literal</span> <span class="o">=</span> <span class="n">default_literal</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Type(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">INT_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
<span class="n">BOOL_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="s2">&quot;False&quot;</span><span class="p">)</span>
<span class="n">TUPLE_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="s2">&quot;tuple&quot;</span><span class="p">,</span> <span class="s2">&quot;tuple()&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">get_type</span></code> returns a syntactical type either for the type name or a value of the type.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_type</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ValueType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">INT_TYPE</span> <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span> <span class="k">else</span> <span class="p">(</span><span class="n">TUPLE_TYPE</span> <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="s2">&quot;tuple&quot;</span> <span class="k">else</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">INT_TYPE</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">BOOL_TYPE</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TUPLE_TYPE</span>

    <span class="k">assert</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we define the classes for variables, <em>stores</em> and <em>environments</em>. A variable has a name and a type. An store is a mapping from variables to values. Environments encapsulate a store and a repository of defined functions. Environments are used to evaluate expressions, and are updated by executing statements (note that minipy expressions are side-effect free, apart from the fact that their evaluation may raise exceptions).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Variable</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Variable(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>
<span class="kn">import</span> <span class="nn">copy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Store</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Variable</span><span class="p">,</span> <span class="n">ValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Variable</span><span class="p">,</span> <span class="n">ValueType</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">env</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Variable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Variable</span><span class="p">]:</span>
        <span class="n">maybe_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">variable</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">maybe_var</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">maybe_var</span> <span class="k">else</span> <span class="n">maybe_var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span>
            <span class="n">maybe_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">maybe_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">maybe_var</span><span class="p">]</span>

            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attempt to read uninitialized variable </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span>
        <span class="n">maybe_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maybe_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">existing_type</span> <span class="o">=</span> <span class="n">maybe_var</span><span class="o">.</span><span class="n">type</span>
            <span class="k">if</span> <span class="n">existing_type</span> <span class="o">!=</span> <span class="n">key</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incompatible assignment types for variable </span><span class="si">{</span><span class="n">key</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: &quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">, previously: </span><span class="si">{</span><span class="n">existing_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">env</span>
    
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Store(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">store</span> <span class="o">=</span> <span class="n">Store</span><span class="p">()</span>
<span class="n">store</span><span class="p">[</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">store</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>42
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
    <span class="n">store</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Traceback (most recent call last):
  File &quot;/tmp/ipykernel_1384/3540991285.py&quot;, line 2, in &lt;module&gt;
    store[&quot;a&quot;]
  File &quot;/tmp/ipykernel_1384/448858491.py&quot;, line 31, in __getitem__
    raise AttributeError(f&quot;Attempt to read uninitialized variable {item}&quot;)
AttributeError: Attempt to read uninitialized variable a (expected)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">store</span><span class="p">[</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">17</span>
<span class="n">store</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>17
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
    <span class="n">store</span><span class="p">[</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">BOOL_TYPE</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Traceback (most recent call last):
  File &quot;/tmp/ipykernel_1384/3534397449.py&quot;, line 2, in &lt;module&gt;
    store[Variable(&quot;x&quot;, BOOL_TYPE)] = False
  File &quot;/tmp/ipykernel_1384/448858491.py&quot;, line 39, in __setitem__
    raise RuntimeError(f&quot;Incompatible assignment types for variable {key.name}: &quot;
RuntimeError: Incompatible assignment types for variable x: bool, previously: int (expected)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Environment</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">store</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Store</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">functions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Variable</span><span class="p">],</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">:</span> <span class="n">Store</span> <span class="o">=</span> <span class="n">Store</span><span class="p">()</span> <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">store</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Variable</span><span class="p">],</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="p">{}</span> <span class="k">if</span> <span class="n">functions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_default_functions</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_default_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s2">&quot;len&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">TUPLE_TYPE</span><span class="p">),),</span> <span class="n">INT_TYPE</span><span class="p">,</span> <span class="nb">len</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Environment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">has_var</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attempt to read uninitialized function/variable </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">has_var</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Environment(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
</pre></div>
</div>
</div>
</div>
<p>We add the <code class="docutils literal notranslate"><span class="pre">len</span></code> function as a default (library) function into our environment. Other Python library functions than <code class="docutils literal notranslate"><span class="pre">len</span></code> and those defined in the executed code (or explicitly supplied to the <code class="docutils literal notranslate"><span class="pre">Environment</span></code> constructor) will not be supported by the interpreter. If needed, they can be registered in the <code class="docutils literal notranslate"><span class="pre">add_default_functions</span></code> function.</p>
<p>We are now ready to define the minipy interpreter. Its top-level functions are <code class="docutils literal notranslate"><span class="pre">execute(self,</span> <span class="pre">stmt:</span> <span class="pre">ASTNode,</span> <span class="pre">environment:</span> <span class="pre">Environment)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></code> for the execution of statements, and <code class="docutils literal notranslate"><span class="pre">evaluate(self,</span> <span class="pre">expr:</span> <span class="pre">Expression,</span> <span class="pre">environment:</span> <span class="pre">Environment)</span> <span class="pre">-&gt;</span> <span class="pre">ValueType</span></code> for the evaluation of expressions. Both functions basically delegate to appropriate interpretation functions based on a dictionary from nonterminals to interpretations. Note that expression statements are not supported in minipy; otherwise, the <code class="docutils literal notranslate"><span class="pre">execute</span></code> function would have to call into <code class="docutils literal notranslate"><span class="pre">evaluate</span></code>.<a class="footnote-reference brackets" href="#side-effects" id="id4">3</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Interpreter</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">,</span> <span class="n">Environment</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">Expression</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">,</span> <span class="n">Environment</span><span class="p">],</span> <span class="n">ValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
            
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="n">t</span><span class="p">](</span><span class="n">stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">assert</span> <span class="kc">False</span>
            
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">[</span><span class="n">t</span><span class="p">](</span><span class="n">expr</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="k">assert</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<p>The evaluation function for the <code class="docutils literal notranslate"><span class="pre">&lt;sum&gt;</span></code> nonterminal, for example, looks like follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">evaluate_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
    <span class="n">operator_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">}</span>

    <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">operator_map</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">](</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>
</div>
<p>We model abrupt completion by special exception classes. For example, executing a <code class="docutils literal notranslate"><span class="pre">break</span></code> statement yields a <code class="docutils literal notranslate"><span class="pre">Break</span></code> exception object, that can be caught by the interpretation of a <code class="docutils literal notranslate"><span class="pre">while</span></code> statement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AbruptCompletionNoException</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Return</span><span class="p">(</span><span class="n">AbruptCompletionNoException</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ValueType</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>


<span class="k">class</span> <span class="nc">Continue</span><span class="p">(</span><span class="n">AbruptCompletionNoException</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Halt</span><span class="p">(</span><span class="n">AbruptCompletionNoException</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Break</span><span class="p">(</span><span class="n">AbruptCompletionNoException</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">execute_break</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">Break</span><span class="p">()</span>
</pre></div>
</div>
<p>The code evaluating a <code class="docutils literal notranslate"><span class="pre">while</span></code> statement, shown below, catches <code class="docutils literal notranslate"><span class="pre">break</span></code>s and <code class="docutils literal notranslate"><span class="pre">continue</span></code>s. Furthermore, it demonstrates the meta-interpreter character of our minipy interpreter: All language features of minipy are mirrored by our interpreter in full Python.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">execute_while_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">WhileStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">eval_guard_res</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span>

    <span class="k">while</span> <span class="n">eval_guard_res</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Continue</span><span class="p">:</span>
            <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">except</span> <span class="n">Break</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="k">return</span>
</pre></div>
</div>
<p>To inspect the full code of the interpreter, press the toggle on the right.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">operator</span>

<span class="k">class</span> <span class="nc">Interpreter</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">,</span> <span class="n">Environment</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Stmts</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_stmts</span><span class="p">,</span>
            <span class="n">Pass</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_pass</span><span class="p">,</span>
            <span class="n">BreakStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_break</span><span class="p">,</span>
            <span class="n">ContinueStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_continue</span><span class="p">,</span>
            <span class="n">ReturnStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_return_stmt</span><span class="p">,</span>
            <span class="n">Assert</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_assert_stmt</span><span class="p">,</span>
            <span class="n">Assignment</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_assignment</span><span class="p">,</span>
            <span class="n">Block</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">,</span>
            <span class="n">FunctionDef</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_function_def</span><span class="p">,</span>
            <span class="n">TryStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_try_stmt</span><span class="p">,</span>
            <span class="n">WhileStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_while_stmt</span><span class="p">,</span>
            <span class="n">IfStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_if_stmt</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">Expression</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">,</span> <span class="n">Environment</span><span class="p">],</span> <span class="n">ValueType</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Disjunction</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_disjunction</span><span class="p">,</span>
            <span class="n">Conjunction</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_conjunction</span><span class="p">,</span>
            <span class="n">Inversion</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_inversion</span><span class="p">,</span>
            <span class="n">Comparison</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_comparison</span><span class="p">,</span>
            <span class="n">Sum</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_sum</span><span class="p">,</span>
            <span class="n">Term</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_term</span><span class="p">,</span>
            <span class="n">Factor</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_factor</span><span class="p">,</span>
            <span class="n">TupleNode</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_tuple</span><span class="p">,</span>
            <span class="n">TupleAccess</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_tuple_access</span><span class="p">,</span>
            <span class="n">FunctionCall</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_fun_call</span><span class="p">,</span>
            <span class="n">Param</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_param</span><span class="p">,</span>
            <span class="n">BooleanAtom</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_boolean</span><span class="p">,</span>
            <span class="n">IntAtom</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_int</span><span class="p">,</span>
            <span class="n">NameAtom</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_name</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="n">t</span><span class="p">](</span><span class="n">stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="c1"># Expression Statements</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">execute_stmts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Stmts</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">stmts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">execute_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">execute_break</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Break</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">execute_continue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Continue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">execute_return_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ReturnStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">Return</span><span class="p">(</span><span class="n">eval_expr_result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">execute_assert_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Assert</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">eval_expr_result</span>

    <span class="k">def</span> <span class="nf">execute_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Assignment</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">environment</span><span class="p">[</span><span class="n">Variable</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">get_type</span><span class="p">(</span><span class="n">eval_expr_result</span><span class="p">))]</span> <span class="o">=</span> <span class="n">eval_expr_result</span>

    <span class="k">def</span> <span class="nf">execute_function_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">FunctionDef</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">f_name</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">name</span>
        <span class="n">ret_type</span> <span class="o">=</span> <span class="n">get_type</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate_param</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">params</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">new_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="n">new_env</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="n">new_env</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Return</span> <span class="k">as</span> <span class="n">ret</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">value</span>

        <span class="n">environment</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ret_type</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="n">Param</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Variable</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">get_type</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">execute_try_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">TryStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">exc</span><span class="p">),</span> <span class="n">AbruptCompletionNoException</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exc</span>

            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">exc_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">caught_exc_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">&quot;builtins&quot;</span><span class="p">],</span> <span class="n">stmt</span><span class="o">.</span><span class="n">exc_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">exc</span><span class="p">),</span> <span class="n">caught_exc_type</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">except_block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">except_block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">execute_if_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">IfStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">eval_expr_result</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span>

        <span class="k">if</span> <span class="n">eval_expr_result</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">then_block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                <span class="k">return</span>

    <span class="k">def</span> <span class="nf">execute_while_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">WhileStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">eval_guard_res</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span>

        <span class="k">while</span> <span class="n">eval_guard_res</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Continue</span><span class="p">:</span>
                <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">except</span> <span class="n">Break</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                <span class="k">return</span>

    <span class="k">def</span> <span class="nf">execute_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Block</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a_stmt</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">stmts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">a_stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">[</span><span class="n">t</span><span class="p">](</span><span class="n">expr</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">evaluate_disjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Disjunction</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">conjunctions</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">environment</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">evaluate_conjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Conjunction</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">inversions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">environment</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">evaluate_inversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Inversion</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inversion</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Comparison</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="n">operator_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;==&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span>
            <span class="s2">&quot;!=&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">,</span>
            <span class="s2">&quot;&lt;=&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
            <span class="s2">&quot;&gt;=&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span>
            <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span>
            <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span>
        <span class="p">}</span>

        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operator_map</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">](</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="n">operator_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">}</span>

        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operator_map</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">](</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Term</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="n">operator_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;*&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
            <span class="s2">&quot;//&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">//</span> <span class="n">b</span><span class="p">,</span>
            <span class="s2">&quot;%&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mod</span>
        <span class="p">}</span>

        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operator_map</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">](</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Factor</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="n">eval_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factor</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">symb</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">eval_res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eval_res</span>

    <span class="k">def</span> <span class="nf">evaluate_fun_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">FunctionCall</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="n">f_name</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">f_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;name &#39;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">&#39; is not defined&quot;</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">ret_type</span><span class="p">,</span> <span class="n">fun</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span><span class="si">}</span><span class="s2">) takes </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;argument(s) but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2"> were given&quot;</span><span class="p">)</span>
        <span class="n">fun_result</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">fun_result</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ret_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected return type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">fun_result</span><span class="p">)</span><span class="si">}</span><span class="s2"> for function &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">&#39;, expected </span><span class="si">{</span><span class="n">ret_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fun_result</span>

    <span class="k">def</span> <span class="nf">evaluate_tuple_access</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">TupleAccess</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="n">eval_atom_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">eval_atom_res</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">eval_atom_res</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
        <span class="n">eval_expr_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">eval_expr_res</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;list indices must be integers, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">eval_expr_res</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">eval_atom_res</span><span class="p">[</span><span class="n">eval_expr_res</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">evaluate_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">NameAtom</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">environment</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">evaluate_boolean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">BooleanAtom</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">evaluate_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">IntAtom</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">number</span>

    <span class="k">def</span> <span class="nf">evaluate_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">TupleNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueType</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">elems</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">interpreter</span> <span class="o">=</span> <span class="n">Interpreter</span><span class="p">()</span>
<span class="n">environment</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="n">interpreter</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">parse_expr</span><span class="p">(</span><span class="s2">&quot;3 + 4 * 2&quot;</span><span class="p">),</span> <span class="n">environment</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>11
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">interpreter</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">parse_expr</span><span class="p">(</span><span class="s2">&quot;(3 + 4) * 2&quot;</span><span class="p">),</span> <span class="n">environment</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>14
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
    <span class="n">interpreter</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">parse_expr</span><span class="p">(</span><span class="s2">&quot;1 // 0&quot;</span><span class="p">),</span> <span class="n">environment</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Traceback (most recent call last):
  File &quot;/tmp/ipykernel_1384/1620470182.py&quot;, line 2, in &lt;module&gt;
    interpreter.evaluate(parse_expr(&quot;1 // 0&quot;), environment)
  File &quot;/tmp/ipykernel_1384/741837800.py&quot;, line 149, in evaluate
    return self.expr_interpretations[t](expr, environment)
  File &quot;/tmp/ipykernel_1384/741837800.py&quot;, line 201, in evaluate_term
    return operator_map[expr.op](left, right)
  File &quot;/tmp/ipykernel_1384/741837800.py&quot;, line 194, in &lt;lambda&gt;
    &quot;//&quot;: lambda a, b: a // b,
ZeroDivisionError: integer division or modulo by zero (expected)
</pre></div>
</div>
</div>
</div>
<p>Let’s try something more complex: Executing our linear search method <code class="docutils literal notranslate"><span class="pre">find</span></code> from above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">program</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def find(needle: int, haystack: tuple) -&gt; int:</span>
<span class="s2">    i = 0</span>
<span class="s2">    while i &lt; len(haystack):</span>
<span class="s2">        if haystack[i] == needle:</span>
<span class="s2">            break</span>
<span class="s2">        else:</span>
<span class="s2">            i = i + 1</span>
<span class="s2">            continue</span>
<span class="s2">    else:</span>
<span class="s2">        return -1</span>
<span class="s2">    return i</span>
<span class="s2">    </span>
<span class="s2">t = (1, 2, 3, 4, )</span>
<span class="s2">x = find(3, t)</span>
<span class="s2">y = find(5, t)</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span><span class="p">,</span> <span class="n">Markdown</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">display_program</span><span class="p">(</span><span class="n">program</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="n">display</span><span class="p">(</span><span class="n">Markdown</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;```python</span><span class="se">\n</span><span class="si">{</span><span class="n">program</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">```&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display_program</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">needle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">haystack</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>
    
<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">environment</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">program</span><span class="p">),</span> <span class="n">environment</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">environment</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">environment</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1
</pre></div>
</div>
</div>
</div>
<p>This seems to work!</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p id="id5"><dl class="citation">
<dt class="label" id="id38"><span class="brackets"><a class="fn-backref" href="#id3">For02</a></span></dt>
<dd><p>Bryan Ford. Packrat Parsing: Simple, Powerful, Lazy, Linear Time, Functional Pearl. In Mitchell Wand and Simon L. Peyton Jones, editors, <em>Proceedings of the Seventh ACM SIGPLAN International Conference on Functional Programming (ICFP)</em>, 36–47. ACM, 2002. URL: <a class="reference external" href="https://doi.org/10.1145/581478.581483">https://doi.org/10.1145/581478.581483</a>, <a class="reference external" href="https://doi.org/10.1145/581478.581483">doi:10.1145/581478.581483</a>.</p>
</dd>
</dl>
</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="while-else"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>The code demonstrates that minipy does support Pythons <code class="docutils literal notranslate"><span class="pre">while</span></code>-<code class="docutils literal notranslate"><span class="pre">else</span></code> syntax: The <code class="docutils literal notranslate"><span class="pre">else</span></code> branch after a
<code class="docutils literal notranslate"><span class="pre">while</span></code> loop is entered whenever the loop completed normally (and the guard evaluated to <code class="docutils literal notranslate"><span class="pre">False</span></code>), that is, not because
of a <code class="docutils literal notranslate"><span class="pre">break</span></code>, <code class="docutils literal notranslate"><span class="pre">return</span></code>, or thrown exception.</p>
</dd>
<dt class="label" id="print-strings"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>The below code is not a minipy program, since minipy does not support strings or print statements. We clearly mark minipy code boxes throughout this book; Python boxes are not marked.</p>
</dd>
<dt class="label" id="side-effects"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>minipy expressions do not have side effects, which is why expression statements, as supported in Python, are quite pointless in our subset. Expressions can call functions, but in the absence of a heap and <code class="docutils literal notranslate"><span class="pre">global</span></code> / <code class="docutils literal notranslate"><span class="pre">nonlocal</span></code> specifiers, functions have no means to change the outer state.</p>
</dd>
</dl>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="intro.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Introduction</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="foundations.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Foundations</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Dominic Steinhöfel<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>