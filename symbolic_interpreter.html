
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A Symbolic Interpreter and Correctness of Symbolic Transitions &#8212; Symbolic Execution: Foundations, Techniques, Applications and Future Perspectives</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/page.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Correctness of Symbolic Transitions" href="correctness.html" />
    <link rel="prev" title="Syntax and Semantics of Symbolic States" href="semantics.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Symbolic Execution: Foundations, Techniques, Applications and Future Perspectives</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Introduction
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="minipy.html">
   Parser and Interpreter for minipy
  </a>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="foundations.html">
   Foundations
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="constraint_solving.html">
     Constraint Solving
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="semantics.html">
     Syntax and Semantics of Symbolic States
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     A Symbolic Interpreter and Correctness of Symbolic Transitions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="correctness.html">
     Correctness of Symbolic Transitions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="techniques.html">
   Techniques
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="transparent_function_execution.html">
     Transparent Symbolic Execution of Function Calls
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="static_loops.html">
     Loops in Static Symbolic Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="compositional.html">
     Compositional Symbolic Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="concolic.html">
     Concolic Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="stateexplosion.html">
     Tackling State Explosion
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="selective.html">
     Selective Symbolic Execution
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="applications.html">
   Applications
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="proving.html">
     Program Proving
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fuzzing.html">
     Symbolic Fuzzing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="debugging.html">
     Symbolic Debugging
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perspectives.html">
   Future Perspectives
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="conclusion.html">
   Conclusion
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/symbolic_interpreter.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/rindPHI/se-book-festschrift-rh"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/rindPHI/se-book-festschrift-rh/issues/new?title=Issue%20on%20page%20%2Fsymbolic_interpreter.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#symbolic-execution-trees">
   Symbolic Execution Trees
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#evaluating-expressions">
   Evaluating Expressions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#executing-statements">
   Executing Statements
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="a-symbolic-interpreter-and-correctness-of-symbolic-transitions">
<span id="foundations-symbolic-interpreter"></span><h1>A Symbolic Interpreter and Correctness of Symbolic Transitions<a class="headerlink" href="#a-symbolic-interpreter-and-correctness-of-symbolic-transitions" title="Permalink to this headline">¶</a></h1>
<p>Executing a program with the concrete minipy interpreter updates the passed environment, and potentially raises an exception. Symbolic execution, in contrast, takes into account all feasible paths through a program. We distinguish between <em>online</em> and <em>offline</em> SE (see, e.g., <span id="id1">[<a class="reference internal" href="#id155"><span>BCCDElia+18</span></a>]</span>). Online SE executes multiple symbolic paths simultaneously: For example, executing an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement leads to two paths which are both explored. Offline SE reasons about one single path at a time. <em>Concolic execution</em>, where SE is guided by a single <em>concrete</em> input, is an example of the latter class. In this section, we regard <em>online</em> SE. Symbolically executing a program in an online symbolic interpreter results in multiple output environments. Also, such an interpreter cannot simply raise an exception, as this would result in a premature termination of the analysis, skipping other feasible program paths. The consequences for our static, online symbolic interpreter are:</p>
<ul class="simple">
<li><p>Instead of updating the initial symbolic environment, the interpreter produces potentially multiple new environments. Our interpreter even outputs all <em>intermediate</em> states, such that the output is a <em>Symbolic Execution Tree</em> (SET).</p></li>
<li><p>Thrown exceptions are stored in the symbolic environment instead of being raise. Thus, we need another field in our <code class="docutils literal notranslate"><span class="pre">SymbolicEnvironment</span></code> class.</p></li>
</ul>
<p>We implement these changes subsequently. Afterward, we show how to implement a static, online symbolic interpreter for minipy, and introduce the correctness properties <em>exhaustiveness</em> and <em>precision</em> for symbolic execution. Finally, we show how these definitions can be used to <em>automatically test</em> the symbolic interpreter. Using this methodology, we discovered two bugs of precious versions of our implementation, one of which is related to a subtle difference in the division semantics in z3 and Python.</p>
<div class="section" id="symbolic-execution-trees">
<h2>Symbolic Execution Trees<a class="headerlink" href="#symbolic-execution-trees" title="Permalink to this headline">¶</a></h2>
<p>We first update the implementation of <code class="docutils literal notranslate"><span class="pre">SymbolicEnvironment</span></code> to include abrupt completion information:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">utils</span>
<span class="kn">from</span> <span class="nn">minipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">constraint_solving</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">semantics</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicEnvironment</span><span class="p">(</span><span class="n">SymbolicEnvironment</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">store</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SymbolicStore</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">path_constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">abrupt_completion</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">functions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Variable</span><span class="p">],</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">path_constraints</span><span class="p">,</span> <span class="n">functions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span> <span class="o">=</span> <span class="n">abrupt_completion</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">SymbolicValueType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SymbolicEnvironment&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_abrupt_completion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;SymbolicEnvironment&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SymbolicEnvironment&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_false</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">constraint</span><span class="p">)):</span>
            <span class="n">new_constraints</span> <span class="o">=</span> <span class="p">{</span><span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">False</span><span class="p">)}</span>
        <span class="k">elif</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_true</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">constraint</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">old_constraints</span> <span class="o">=</span> <span class="p">{</span><span class="n">other_constraint</span> <span class="k">for</span> <span class="n">other_constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span>
                               <span class="k">if</span> <span class="ow">not</span> <span class="n">implies</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">other_constraint</span><span class="p">)}</span>
            <span class="n">new_constraints</span> <span class="o">=</span> <span class="n">old_constraints</span> <span class="o">|</span> <span class="p">{</span><span class="n">constraint</span><span class="p">}</span>


        <span class="k">return</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">,</span> <span class="n">new_constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Variable</span><span class="p">],</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">impl</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SymbolicEnvironment&#39;</span><span class="p">:</span>
        <span class="n">new_functions</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>
        <span class="n">new_functions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">impl</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">,</span> <span class="n">new_functions</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;(&quot;</span> <span class="o">+</span>
                <span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">))</span> <span class="o">+</span>
                <span class="s2">&quot;)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_html</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prev_html</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">in_html_mode</span><span class="p">()</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">set_html_mode</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path_constraint_to_html</span><span class="p">()</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">to_html</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="n">z3</span><span class="o">.</span><span class="n">set_html_mode</span><span class="p">(</span><span class="n">prev_html</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">path_constraint_to_html</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prev_html</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">in_html_mode</span><span class="p">()</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">set_html_mode</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">path_constraint_string</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">:</span>
            <span class="n">path_constraint_string</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">z3_html_escape</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">obj_to_string</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">)))</span>
        <span class="n">path_constraint_string</span> <span class="o">+=</span> <span class="s2">&quot;}&quot;</span>
        <span class="n">path_constraint_string</span> <span class="o">=</span> <span class="n">path_constraint_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;BR/&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&amp;nbsp;&quot;</span><span class="p">)</span>

        <span class="n">z3</span><span class="o">.</span><span class="n">set_html_mode</span><span class="p">(</span><span class="n">prev_html</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path_constraint_string</span>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;SymbolicEnvironment(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span> \
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span> \
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="nb">repr</span><span class="p">({</span><span class="n">f_name</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;fun </span><span class="si">{</span><span class="n">f_name</span><span class="si">}{</span><span class="n">params</span><span class="si">}</span><span class="s2"> -&gt; &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">f_name</span><span class="p">,</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">store</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">path_constraints</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">path_constraints</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">functions</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">abrupt_completion</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="n">ExceptionWrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">)</span> <span class="o">==</span> <span class="n">ExceptionWrapper</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we define a class for nodes in an SET. An SET node comprises a symbolic environment and a string representation of the next instruction to execute. We also define a <code class="docutils literal notranslate"><span class="pre">to_html</span></code> method to produce pretty output.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SETNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">,</span> <span class="n">pc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ParseTree</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">environment</span> <span class="o">=</span> <span class="n">environment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">pc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pc</span>

    <span class="nd">@pc</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ParseTree</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]):</span>
        <span class="k">if</span> <span class="n">pc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__pc</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__pc</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_html</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prev_html</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">in_html_mode</span><span class="p">()</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">set_html_mode</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&lt;TABLE BORDER=&quot;0&quot;&gt;&lt;TR&gt;&#39;</span>
        <span class="k">if</span> <span class="s2">&quot;&lt;BR/&gt;&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">to_html</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;&lt;TD BALIGN=&quot;LEFT&quot; ALIGN=&quot;LEFT&quot;&gt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">to_html</span><span class="p">()</span><span class="si">}</span><span class="s1">&lt;/TD&gt;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;&lt;TD&gt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">to_html</span><span class="p">()</span><span class="si">}</span><span class="s1">&lt;/TD&gt;&#39;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&lt;/TR&gt;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s1">&#39;&lt;TR&gt;&lt;TD ALIGN=&quot;CENTER&quot;&gt;&lt;FONT FACE=&quot;Courier&quot;&gt;&#39;</span> <span class="o">+</span> <span class="n">z3_html_escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&quot;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&lt;/TABLE&gt;&quot;</span>

        <span class="n">z3</span><span class="o">.</span><span class="n">set_html_mode</span><span class="p">(</span><span class="n">prev_html</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;SETNode(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">environment</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">environment</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">environment</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">pc</span>
</pre></div>
</div>
</div>
</div>
<p>Symbolic execution trees themselves are defined just like derivation trees, only with <code class="docutils literal notranslate"><span class="pre">SETNode</span></code>s instead of strings as nodes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">SET</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">SETNode</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;SET&#39;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<p>The following function produces graphical representations (using GraphViz) of SETs. Leaves are highlighted using the following color scheme: Red leaves represent raised exceptions, green leaves represent nodes with unsatisfiable path conditions, and blue leaves all other nodes containing “normal” computation results.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graphviz</span> <span class="kn">import</span> <span class="n">Digraph</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">display_set</span><span class="p">(</span><span class="n">symbolic_execution_tree</span><span class="p">:</span> <span class="n">SET</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Digraph</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">traverse_tree</span><span class="p">(</span><span class="n">dot</span><span class="p">:</span> <span class="n">Digraph</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">SET</span><span class="p">,</span> <span class="n">node_id</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">tree</span>
        
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;fillcolor&quot;</span><span class="p">:</span> <span class="s2">&quot;lightgreen&quot;</span><span class="p">,</span> <span class="s2">&quot;style&quot;</span><span class="p">:</span> <span class="s2">&quot;filled&quot;</span><span class="p">}</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">abrupt_completion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
              <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">abrupt_completion</span><span class="p">,</span> <span class="n">AbruptCompletionNoException</span><span class="p">)):</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;fillcolor&quot;</span><span class="p">:</span> <span class="s2">&quot;lightpink1&quot;</span><span class="p">,</span> <span class="s2">&quot;style&quot;</span><span class="p">:</span> <span class="s2">&quot;filled&quot;</span><span class="p">}</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;fillcolor&quot;</span><span class="p">:</span> <span class="s2">&quot;paleturquoise2&quot;</span><span class="p">,</span> <span class="s2">&quot;style&quot;</span><span class="p">:</span> <span class="s2">&quot;filled&quot;</span><span class="p">}</span>

        <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">node_id</span><span class="p">),</span> <span class="s2">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">to_html</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">_attributes</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">children</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="k">nonlocal</span> <span class="n">counter</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">child_id</span> <span class="o">=</span> <span class="n">counter</span>
                <span class="n">dot</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">node_id</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">child_id</span><span class="p">))</span>
                <span class="n">traverse_tree</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">child_id</span><span class="p">)</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dot</span> <span class="o">=</span> <span class="n">Digraph</span><span class="p">(</span><span class="n">comment</span><span class="o">=</span><span class="s2">&quot;Symbolic Execution Tree&quot;</span><span class="p">)</span>
    <span class="n">dot</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;box&#39;</span><span class="p">)</span>
    <span class="n">traverse_tree</span><span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="n">symbolic_execution_tree</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dot</span>
</pre></div>
</div>
</div>
</div>
<p>Recall our small example from the previous section:</p>
<div class="cell tag_minipy docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
</pre></div>
</div>
</div>
</div>
<p>The final SET resulting from symbolically executing this program will contain two leaves, one branch each for the case where the condition of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statements hold or does not hold, respectively. Apart from the root, it also contains two inner nodes corresponding to the first assignment and the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement. In the absence of an implemented symbolic interpreter, we manually construct this SET:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)</span>

<span class="n">env_0</span> <span class="o">=</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="n">SymbolicStore</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">to_z3</span><span class="p">(),</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">to_z3</span><span class="p">()}))</span>
<span class="n">env_1</span> <span class="o">=</span> <span class="n">env_0</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">to_z3</span><span class="p">())</span>
<span class="n">env_2</span> <span class="o">=</span> <span class="n">env_1</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">to_z3</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">env_2_1</span> <span class="o">=</span> <span class="n">env_2</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">to_z3</span><span class="p">())</span>
<span class="n">env_3</span> <span class="o">=</span> <span class="n">env_1</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">to_z3</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">env_0</span><span class="p">,</span> <span class="s2">&quot;x = 2 * y&quot;</span><span class="p">)</span>
<span class="n">if_node</span> <span class="o">=</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">env_1</span><span class="p">,</span> <span class="s2">&quot;if x &lt; 0:&quot;</span><span class="p">)</span>
<span class="n">inversion_node</span> <span class="o">=</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">env_2</span><span class="p">,</span> <span class="s2">&quot;x = -x&quot;</span><span class="p">)</span>
<span class="n">leave_1</span> <span class="o">=</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">env_2_1</span><span class="p">)</span>
<span class="n">leave_2</span> <span class="o">=</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">env_3</span><span class="p">)</span>

<span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">if_node</span><span class="p">,</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">inversion_node</span><span class="p">,</span> <span class="p">[(</span><span class="n">leave_1</span><span class="p">,</span> <span class="p">[])]),</span>
        <span class="p">(</span><span class="n">leave_2</span><span class="p">,</span> <span class="p">[])])])</span>

<span class="n">display_set</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/symbolic_interpreter_16_0.svg" src="_images/symbolic_interpreter_16_0.svg" /></div>
</div>
</div>
<div class="section" id="evaluating-expressions">
<h2>Evaluating Expressions<a class="headerlink" href="#evaluating-expressions" title="Permalink to this headline">¶</a></h2>
<p>Also the symbolic evaluation of expressions can have multiple results. Consider the expression <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">//</span> <span class="pre">x</span></code>: Depending on whether <code class="docutils literal notranslate"><span class="pre">x</span></code> is zero or non-zero, evaluating this expression results in a value or a <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>. Thus, our result type for expression evaluation is a collection of pairs of either a value or an exception, together with a boolean constraint signaling under which condition the respective result is returned.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">EvalExprResult</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<p>We define a helper function <code class="docutils literal notranslate"><span class="pre">handle_binary_operation</span></code> computing all conditioned results for a binary operation (e.g., division or conjunction) applied on two evaluation results.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handle_binary_operation</span><span class="p">(</span><span class="n">left</span><span class="p">:</span> <span class="n">EvalExprResult</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">EvalExprResult</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">left_result</span> <span class="ow">in</span> <span class="n">left</span><span class="p">:</span>
        <span class="n">left_val</span><span class="p">,</span> <span class="n">left_constr</span> <span class="o">=</span> <span class="n">left_result</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_val</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_result</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;and&quot;</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">False</span><span class="p">),</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">left_constr</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">left_val</span><span class="p">)))))</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;or&quot;</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">left_constr</span><span class="p">,</span> <span class="n">left_val</span><span class="p">))))</span>

        <span class="k">for</span> <span class="n">right_result</span> <span class="ow">in</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">right_val</span><span class="p">,</span> <span class="n">right_constr</span> <span class="o">=</span> <span class="n">right_result</span>
            <span class="n">constraint_conjunction</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">left_constr</span><span class="p">,</span> <span class="n">right_constr</span><span class="p">)</span>
            <span class="n">constraint_conjunction</span> <span class="o">=</span> <span class="n">z3_and</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_false</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_val</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="c1"># Short-circuit evaluation:</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;or&quot;</span><span class="p">:</span>
                    <span class="n">constraint_conjunction</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">left_val</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;and&quot;</span><span class="p">:</span>
                    <span class="n">constraint_conjunction</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">,</span> <span class="n">left_val</span><span class="p">)</span>

                <span class="n">constraint_conjunction</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_false</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">right_val</span><span class="p">,</span> <span class="n">constraint_conjunction</span><span class="p">))</span>

                <span class="k">continue</span>

            <span class="n">left_val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">z3</span><span class="o">.</span><span class="n">ArithRef</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]</span>
            <span class="n">right_val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">z3</span><span class="o">.</span><span class="n">ArithRef</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;and&quot;</span><span class="p">:</span>
                <span class="n">constraint_conjunction</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">,</span> <span class="n">left_val</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_false</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">right_val</span><span class="p">,</span> <span class="n">constraint_conjunction</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;or&quot;</span><span class="p">:</span>
                <span class="n">constraint_conjunction</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">left_val</span><span class="p">)))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_false</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">right_val</span><span class="p">,</span> <span class="n">constraint_conjunction</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="n">operator_map</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqRef</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span>
                <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
                <span class="s2">&quot;*&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
                <span class="s2">&quot;==&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span>
                <span class="s2">&quot;!=&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">),</span>
                <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span>
                <span class="s2">&quot;&lt;=&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
                <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span>
                <span class="s2">&quot;&gt;=&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span>
                <span class="c1"># &quot;and&quot;: lambda a, b: z3.And(a, b),</span>
                <span class="c1"># &quot;or&quot;: lambda a, b: z3.Or(a, b)</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operator_map</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">operator_map</span><span class="p">[</span><span class="n">op</span><span class="p">](</span><span class="n">left_val</span><span class="p">,</span> <span class="n">right_val</span><span class="p">),</span> <span class="n">constraint_conjunction</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="n">right_zero</span> <span class="o">=</span> <span class="n">right_val</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">right_nonzero</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">right_zero</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;//&quot;</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">ToInt</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">ToReal</span><span class="p">(</span><span class="n">left_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">z3</span><span class="o">.</span><span class="n">ToReal</span><span class="p">(</span><span class="n">right_val</span><span class="p">)),</span>
                               <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">,</span> <span class="n">right_nonzero</span><span class="p">)))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;division by zero&quot;</span><span class="p">),</span>
                               <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">,</span> <span class="n">right_zero</span><span class="p">)))</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;%&quot;</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">left_val</span> <span class="o">%</span> <span class="n">right_val</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">,</span> <span class="n">right_nonzero</span><span class="p">)))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;division by zero&quot;</span><span class="p">),</span>
                               <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">constraint_conjunction</span><span class="p">,</span> <span class="n">right_zero</span><span class="p">)))</span>
                <span class="k">continue</span>

            <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">handle_binary_operation</span><span class="p">(</span>
    <span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">to_z3</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))],</span>
    <span class="p">[(</span><span class="n">y</span><span class="o">.</span><span class="n">to_z3</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))],</span>
    <span class="s2">&quot;//&quot;</span><span class="p">)</span>

<span class="n">display_html</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">[(ToInt(ToReal(x)/ToReal(y)), And(True, Not(0 == y))), (ZeroDivisionError('division by zero'), And(True, 0 == y))]</div></div>
</div>
<p>The term produced for the division, <code class="docutils literal notranslate"><span class="pre">ToInt(ToReal(x)/ToReal(y))</span></code>, might come unexpected: Why not simply <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code>? The reason is the semantics of Python’s Integer division <code class="docutils literal notranslate"><span class="pre">//</span></code>, which is a <em>floor division</em> <a class="footnote-reference brackets" href="#floor-division" id="id2">1</a>. Essentially, Python rounds towards 0 for positive, and away from 0 for negative numbers. That is, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">//</span> <span class="pre">-2</span></code> evaluates to -1, while <code class="docutils literal notranslate"><span class="pre">z3.IntVal(1)</span> <span class="pre">/</span> <span class="pre">z3.IntVal(-2)</span></code> evaluates to <em>0</em>. Since the <code class="docutils literal notranslate"><span class="pre">z3.ToInt</span></code> function rounds away from zero for negative numbers, the implementation above correctly models Python’s (and minipy’s) floor division semantics.</p>
<p>Based on this function, the implementation of expression evaluation can be handled uniformly in many cases. For example, consider the evaluation of sums and terms below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">evaluate_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">handle_binary_operation</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Term</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">handle_binary_operation</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>When evaluating tuple expressions, we sequentially evaluate all tuple elements and add an exception result if one of these evaluations raises an exception. We create a z3 sequence expression for the case where all tuple elements evaluate to a value. Consider the tuple <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">//</span> <span class="pre">(y</span> <span class="pre">+</span> <span class="pre">1))</span></code>. Its symbolic evaluation has three results:</p>
<ol class="simple">
<li><p>y is 0, then the tuple evaluates to a <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>.</p></li>
<li><p>y is -1, then the tuple evaluates to a <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>.</p></li>
<li><p>y does not equal either 0 or -1, then the tuple evaluates to a sequence expression containing the symbolic values corresponding to the division.</p></li>
</ol>
<p>For considering all these options, we build the product of the individual evaluation results for the tuple elements. This yields a list of tuples, where each tuple has the length of the evaluated tuple and corresponds to one evaluation result. For example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result_1</span> <span class="o">=</span> <span class="n">handle_binary_operation</span><span class="p">(</span>
    <span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">to_z3</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))],</span>
    <span class="p">[(</span><span class="n">y</span><span class="o">.</span><span class="n">to_z3</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))],</span>
    <span class="s2">&quot;//&quot;</span><span class="p">)</span>

<span class="n">result_2</span> <span class="o">=</span> <span class="n">handle_binary_operation</span><span class="p">(</span>
    <span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">to_z3</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))],</span>
    <span class="p">[(</span><span class="n">y</span><span class="o">.</span><span class="n">to_z3</span><span class="p">()</span> <span class="o">+</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))],</span>
    <span class="s2">&quot;//&quot;</span><span class="p">)</span>

<span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalExprResult</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">result_1</span><span class="p">,</span> <span class="n">result_2</span><span class="p">]</span>
<span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[((ToInt(ToReal(x)/ToReal(y)), And(True, Not(0 == y))),
  (ToInt(ToReal(x)/ToReal(y + 1)), And(True, Not(0 == y + 1)))),
 ((ToInt(ToReal(x)/ToReal(y)), And(True, Not(0 == y))),
  (ZeroDivisionError(&#39;division by zero&#39;), And(True, 0 == y + 1))),
 ((ZeroDivisionError(&#39;division by zero&#39;), And(True, 0 == y)),
  (ToInt(ToReal(x)/ToReal(y + 1)), And(True, Not(0 == y + 1)))),
 ((ZeroDivisionError(&#39;division by zero&#39;), And(True, 0 == y)),
  (ZeroDivisionError(&#39;division by zero&#39;), And(True, 0 == y + 1)))]
</pre></div>
</div>
</div>
</div>
<p>We loop over the elements of the tuples in the list, and stop at the first exception (if any), which will be the evaluation result. Along the way, we collect the path constraints of the seen evaluation results for the tuple elements. Note that the list above contains four, and not three elements. When considering those, the third and fourth evaluation alternatives collapse to a single one, since we stop after processing the evaluation result for the first tuple element, which is an exception (the fourth element is anyway infeasible, since <code class="docutils literal notranslate"><span class="pre">y</span></code> cannot attain the values 0 and -1 at the same time).</p>
<p>To avoid creating the same result for equivalent evaluations (e.g., if the same exception is raised under the same condition when evaluating different tuple elements), we first collect evaluation results in a set. We wrap exceptions inside a wrapper object computing sensible hashes as Python exceptions generally do not supply a suitable hashing implementation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">evaluate_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">TupleNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">sub_results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalExprResult</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span> 
                                             <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">elems</span><span class="p">]</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">OrderedSet</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]]</span> <span class="o">=</span> <span class="n">OrderedSet</span><span class="p">([])</span>

        <span class="n">combinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">sub_results</span><span class="p">))</span>

        <span class="n">combination</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
            <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">path_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sub_result</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sub_value</span><span class="p">,</span> <span class="n">sub_constraint</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
                <span class="n">path_constraint</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">path_constraint</span><span class="p">,</span> <span class="n">sub_constraint</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">wrap_exceptions</span><span class="p">((</span><span class="n">sub_value</span><span class="p">,</span> <span class="n">path_constraint</span><span class="p">)))</span>
                    <span class="k">break</span>

                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_value</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combination</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">sort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqSortRef</span><span class="p">)</span> 
                            <span class="k">else</span> <span class="n">z3</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">path_constraint</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">sort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqSortRef</span><span class="p">)</span> 
                                        <span class="k">else</span> <span class="n">z3</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]),</span> <span class="n">path_constraint</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">unwrap_exceptions</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>For evaluating tuple access (e.g., <code class="docutils literal notranslate"><span class="pre">t[x]</span></code>), we have to consider the possible exceptions that may arise: Apart form the exceptions raised by evaluating <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> (which can be non-atomic expressions), <code class="docutils literal notranslate"><span class="pre">x</span></code> might be out of range, or <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> might have the wrong sorts (i.e., not <code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">int</span></code>). All this is considered in the following implementation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">handle_tuple_access</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tuple_result</span><span class="p">:</span> <span class="n">EvalExprResult</span><span class="p">,</span>
                            <span class="n">expr_result</span><span class="p">:</span> <span class="n">EvalExprResult</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">EvalExprResult</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">atom_value</span><span class="p">,</span> <span class="n">atom_constraint</span> <span class="ow">in</span> <span class="n">tuple_result</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">atom_value</span><span class="p">,</span> <span class="n">atom_constraint</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom_value</span><span class="o">.</span><span class="n">sort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqSortRef</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">atom_value</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">),</span>
                               <span class="n">atom_constraint</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">expr_value</span><span class="p">,</span> <span class="n">expr_constraint</span> <span class="ow">in</span> <span class="n">expr_result</span><span class="p">:</span>
                <span class="n">conjunction</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">atom_constraint</span><span class="p">,</span> <span class="n">expr_constraint</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr_value</span><span class="p">,</span> <span class="n">conjunction</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">expr_value</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="o">!=</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">():</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;list indices must be integers, not </span><span class="si">{</span><span class="n">expr_value</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span>
                                   <span class="n">conjunction</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="n">atom_value</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqRef</span>

                <span class="n">length_constraint</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">expr_value</span><span class="p">,</span>
                                           <span class="n">expr_value</span> <span class="o">&lt;</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="n">atom_value</span><span class="p">))</span>

                <span class="n">expr</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">atom_value</span><span class="p">[</span><span class="n">expr_value</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">Z3_OP_ITE</span> <span class="ow">and</span> \
                        <span class="n">implies</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">conjunction</span><span class="p">,</span> <span class="n">length_constraint</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">conjunction</span><span class="p">,</span> <span class="n">length_constraint</span><span class="p">)))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;tuple index out of range&quot;</span><span class="p">),</span>
                               <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">conjunction</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">length_constraint</span><span class="p">))))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># ...</span>
</pre></div>
</div>
<p>The execution of function definitions adds a <code class="docutils literal notranslate"><span class="pre">Callable</span></code> to the symbolic environment, which accepts an environment, a list of symbolic arguments, and returns an <code class="docutils literal notranslate"><span class="pre">EvalExprResult</span></code>. The evaluation of a function call has to consider all exceptions thrown when evaluating the arguments. Additionally, an exception is registered if an unexpected number of arguments is given. Note that we do not check argument types, which is generally not done in a dynamically typed language like Python. In minipy, however, we always have complete type information, which is why this problem could be ruled out by a static check taking place before symbolic execution.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">evaluate_fun_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">FunctionCall</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">EvalExprResult</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">f_name</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">f_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;name &#39;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">&#39; is not defined&quot;</span><span class="p">)</span>

        <span class="n">args_result</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>

        <span class="n">combinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">args_result</span><span class="p">))</span>

        <span class="n">combination</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
            <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">path_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sub_result</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sub_value</span><span class="p">,</span> <span class="n">sub_constraint</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
                <span class="n">path_constraint</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">path_constraint</span><span class="p">,</span> <span class="n">sub_constraint</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wrap_exceptions</span><span class="p">((</span><span class="n">sub_value</span><span class="p">,</span> <span class="n">path_constraint</span><span class="p">)))</span>
                    <span class="k">break</span>

                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_value</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combination</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">ret_type</span><span class="p">,</span> <span class="n">fun</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span><span class="si">}</span><span class="s2">) takes </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;argument(s) but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="si">}</span><span class="s2"> were given&quot;</span><span class="p">)</span>

                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">result</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
</div>
<div class="section" id="executing-statements">
<h2>Executing Statements<a class="headerlink" href="#executing-statements" title="Permalink to this headline">¶</a></h2>
<p>Similarly to the evaluation of expressions, the execution of statements has to consider all possible outcomes, such that the execution result is a tree and not a mere update of the environment. We explain the implementation of the execution functions for the stereotypical assignment, <code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">try</span></code>, and <code class="docutils literal notranslate"><span class="pre">while</span></code> statements; moreover, we have a look at the function definitions and calls.</p>
<p>Executing an assignment results in one leaf node per raised exception during the evaluation of the right-hand side, plus a normal evaluation result when the right-hand side evaluates to a value.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">execute_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Assignment</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="n">children</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_expr_result</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                    <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
                            <span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="p">[]</span>
                <span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">get_type_for_z3_expr</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                    <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
                            <span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="p">[]</span>
                <span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>In the case of an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, we have one leaf for each raised exception when evaluating the guard, plus one leaf each for the execution of the then and else branch of the conditional. To avoid creating infeasible subtrees, we add an unsatisfiability check for each case.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">execute_if_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">IfStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="n">result</span><span class="p">:</span> <span class="n">SET</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_expr_result</span><span class="p">:</span>
            <span class="n">new_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">new_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">new_env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
                <span class="k">continue</span>

            <span class="k">assert</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="n">then_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">else_constraint</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

            <span class="n">then_env</span> <span class="o">=</span> <span class="n">new_env</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">then_constraint</span><span class="p">)</span>
            <span class="n">else_env</span> <span class="o">=</span> <span class="n">new_env</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">else_constraint</span><span class="p">)</span>

            <span class="n">then_env_unsat</span> <span class="o">=</span> <span class="n">then_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">()</span>
            <span class="n">else_env_unsat</span> <span class="o">=</span> <span class="n">else_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">then_env_unsat</span><span class="p">:</span>
                <span class="n">else_env_unsat</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">else_env_unsat</span><span class="p">:</span>
                <span class="n">then_env_unsat</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">then_env_unsat</span><span class="p">:</span>
                <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">then_block</span><span class="p">,</span> <span class="n">then_env</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">else_env_unsat</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span><span class="p">,</span> <span class="n">else_env</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">else_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>

        <span class="k">return</span> <span class="n">result</span>

    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>The path condition for the then leg of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement is extended by the constraint corresponding to the evaluation of the guard along with the evaluation result of the guard expression. Including the constraint for the value of the guard is important if its evaluation can raise an exception; then, we may only execute the bodies of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement in the normal completion case.</p>
<p>Executing a <code class="docutils literal notranslate"><span class="pre">try</span></code> statement is relatively simple. The only specialty is that we have to look up exception types from <code class="docutils literal notranslate"><span class="pre">except</span></code> clauses to check whether a raised exception matches the caught type (alternatively, we could resort to simple class name comparisons).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">execute_try_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">TryStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">exc</span><span class="p">),</span> <span class="n">AbruptCompletionNoException</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exc</span>

            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">exc_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">caught_exc_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">&quot;builtins&quot;</span><span class="p">],</span> <span class="n">stmt</span><span class="o">.</span><span class="n">exc_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">exc</span><span class="p">),</span> <span class="n">caught_exc_type</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">except_block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">except_block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">assert</span> <span class="kc">False</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>The most “problematic” statement in symbolic execution of minipy is the <code class="docutils literal notranslate"><span class="pre">while</span></code> statement. Consider the implementation of the <code class="docutils literal notranslate"><span class="pre">execute_while_stmt</span></code> method in the concrete minipy interpreter:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Interpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">execute_while_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">WhileStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">eval_guard_res</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span>

        <span class="k">while</span> <span class="n">eval_guard_res</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Continue</span><span class="p">:</span>
                <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">except</span> <span class="n">Break</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                <span class="k">return</span>

    <span class="c1"># ...</span>
</pre></div>
</div>
<p>The concrete interpreter evaluates the guard, executes the body if the guard evaluates to true, checks for the special <code class="docutils literal notranslate"><span class="pre">Continue</span></code> and <code class="docutils literal notranslate"><span class="pre">Break</span></code> exceptions, and continues doing this until the guard evaluates to false (or a <code class="docutils literal notranslate"><span class="pre">Continue</span></code> or <code class="docutils literal notranslate"><span class="pre">Break</span></code> was encountered). The simplest way of symbolically executing a loop is to mimic this behavior, which is called <em>loop unrolling</em> in SE terminology <span id="id3">[<a class="reference internal" href="transparent_function_execution.html#id173"><span>ABB+16</span></a>]</span> <span id="id4">[<a class="reference internal" href="#id155"><span>BCCDElia+18</span></a>]</span>. Implementing this is not too difficult:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">execute_while_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">WhileStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_guard_res</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">exc_node</span> <span class="o">=</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">exc_node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">exc_node</span><span class="p">,</span> <span class="p">[]))</span>
                <span class="k">continue</span>

            <span class="n">then_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">then_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">then_constraint</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">then_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">then_env</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">subtree</span><span class="p">):</span>
                    <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">leaf</span>
                    <span class="n">env</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span>
                    <span class="n">exc</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">abrupt_completion</span>
                    <span class="k">if</span> <span class="n">exc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">Continue</span><span class="p">):</span>
                            <span class="n">env</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">Break</span><span class="p">):</span>
                            <span class="n">env</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">replace_in_tree</span><span class="p">(</span>
                                <span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="n">while_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">replace_in_tree</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">while_tree</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="n">else_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="n">else_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">else_constraint</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">else_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span><span class="p">,</span> <span class="n">else_env</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">else_env</span><span class="p">,</span> <span class="s1">&#39;else:&#39;</span><span class="p">),</span> <span class="p">[</span><span class="n">subtree</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">else_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>

        <span class="k">return</span> <span class="n">result</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>Apart from the standard differences between the concrete and symbolic interpreter (which correspond to the differences of the respective implementations of the execution of an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement), the most striking difference is that the implementation is recursive, which is a little easier to implement. Furthermore, the execution of the body can, of course, result in a tree with multiple leaves. We replace each leaf from that tree with a leaf indicating what to execute next. For instance, in the case of an encountered <code class="docutils literal notranslate"><span class="pre">Break</span></code>, we replace the leaf node with a single node without children, and reset the abrupt completion flag (<code class="docutils literal notranslate"><span class="pre">env</span> <span class="pre">=</span> <span class="pre">env.set_abrupt_completion(None)</span></code>) since the loop “catches” abrupt completion due to <code class="docutils literal notranslate"><span class="pre">break</span></code> statements. For the normal completion case, we execute the loop once again, and replace the normal completion leaves of the body with the newly generated trees resulting from the loop execution.</p>
<p>The execution of function definition statements in the symbolic interpreter works analogously to the concrete minipy interpreter: We add a continuation to the execution environment which is used when evaluating later calls to the defined functions. The corresponding implementation in the concrete interpreter is</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Interpreter</span><span class="p">:</span>
    
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">execute_function_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">FunctionDef</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">Environment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">f_name</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">name</span>
        <span class="n">ret_type</span> <span class="o">=</span> <span class="n">get_type</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate_param</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">params</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">new_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="n">new_env</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="n">new_env</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Return</span> <span class="k">as</span> <span class="n">ret</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">value</span>

        <span class="n">environment</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ret_type</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>The main difference in the symbolic variant is that it has to account for multiple leaves in the symbolic tree resulting from the execution of the function body:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">execute_function_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">FunctionDef</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">f_name</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">name</span>
        <span class="n">ret_type</span> <span class="o">=</span> <span class="n">get_type</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate_param</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">params</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">SymbolicValueType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="n">environment</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

            <span class="n">block_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="n">result</span><span class="p">:</span> <span class="n">EvalExprResult</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">block_result</span><span class="p">):</span>
                <span class="n">exc</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">abrupt_completion</span>
                <span class="k">if</span> <span class="n">exc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Missing return statement&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">SymbolicReturn</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">exc</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">z3_and</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">exc</span><span class="p">,</span> <span class="n">z3_and</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">)))</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">ret_type</span><span class="p">,</span> <span class="n">func</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[])</span>
        <span class="p">]</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>Function <em>calls</em> are evaluated by first considering all evaluation alternatives for the passed parameters: If the evaluation of a parameter raises an exception, the exception is the result of the call. Only if all parameters evaluate normally, the function body is executed. Similarly to the evaluation of tuple expressions, we build the product of the evaluation results for the parameters to account for all evaluation alternatives.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="c1"># ...</span>
    
    <span class="k">def</span> <span class="nf">evaluate_fun_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">FunctionCall</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">EvalExprResult</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">f_name</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">f_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;name &#39;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">&#39; is not defined&quot;</span><span class="p">)</span>

        <span class="n">args_result</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>

        <span class="n">combinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">args_result</span><span class="p">))</span>

        <span class="n">combination</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
            <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">path_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sub_result</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sub_value</span><span class="p">,</span> <span class="n">sub_constraint</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
                <span class="n">path_constraint</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">path_constraint</span><span class="p">,</span> <span class="n">sub_constraint</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wrap_exceptions</span><span class="p">((</span><span class="n">sub_value</span><span class="p">,</span> <span class="n">path_constraint</span><span class="p">)))</span>
                    <span class="k">break</span>

                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_value</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combination</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">ret_type</span><span class="p">,</span> <span class="n">fun</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span><span class="si">}</span><span class="s2">) takes </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;argument(s) but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="si">}</span><span class="s2"> were given&quot;</span><span class="p">)</span>

                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">result</span>
    
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>The complete code for the symbolic interpreter, along with some helper functions, follows bellow (press the toggle on the right).</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">orderedset</span> <span class="kn">import</span> <span class="n">OrderedSet</span>


<span class="n">SomeTree</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;SomeTree&#39;</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">tree_contains</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">SET</span><span class="p">,</span> <span class="n">needle</span><span class="p">:</span> <span class="n">SET</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">tree</span> <span class="ow">is</span> <span class="n">needle</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">node</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">tree</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">children</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">tree_contains</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">needle</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">replace_in_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">SET</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">:</span> <span class="n">SET</span><span class="p">,</span> <span class="n">new_tree</span><span class="p">:</span> <span class="n">SET</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">tree_contains</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">path_iterator</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="n">to_replace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">replace_tree_path</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">new_tree</span><span class="p">)</span>
        
        
<span class="k">def</span> <span class="nf">replace_tree_path</span><span class="p">(</span><span class="n">in_tree</span><span class="p">:</span> <span class="n">SomeTree</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">replacement_tree</span><span class="p">:</span> <span class="n">SomeTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SomeTree</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;In-place subtree replacement preserving identity of other subtrees.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">replacement_tree</span>

    <span class="n">curr_parent</span> <span class="o">=</span> <span class="n">in_tree</span>
    <span class="n">last_idx</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">curr_tree</span> <span class="o">=</span> <span class="n">curr_parent</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">last_idx</span><span class="p">]</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">while</span> <span class="n">path</span><span class="p">:</span>
        <span class="n">last_idx</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">curr_parent</span> <span class="o">=</span> <span class="n">curr_tree</span>
        <span class="n">curr_tree</span> <span class="o">=</span> <span class="n">curr_tree</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">last_idx</span><span class="p">]</span>

    <span class="n">curr_parent</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">last_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">replacement_tree</span>

    <span class="k">return</span> <span class="n">in_tree</span>

        
<span class="k">def</span> <span class="nf">path_iterator</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">SomeTree</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="p">())</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">SomeTree</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">yield</span> <span class="n">path</span><span class="p">,</span> <span class="n">tree</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">yield from</span> <span class="n">path_iterator</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,))</span>

        
<span class="k">def</span> <span class="nf">get_type_for_z3_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">ExprRef</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">INT_TYPE</span>
    <span class="k">elif</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_seq</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TUPLE_TYPE</span>
    <span class="k">elif</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BOOL_TYPE</span>

    <span class="k">assert</span> <span class="kc">False</span>
    
    
<span class="k">def</span> <span class="nf">implies</span><span class="p">(</span><span class="n">premise</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">,</span> <span class="n">conclusion</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">is_unsat</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">premise</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">conclusion</span><span class="p">)))</span>
        
        
<span class="k">class</span> <span class="nc">SymbolicReturn</span><span class="p">(</span><span class="n">AbruptCompletionNoException</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">SymbolicValueType</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>


<span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">ASTNode</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">,</span> <span class="n">SymbolicEnvironment</span><span class="p">],</span> <span class="n">SET</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Stmts</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_stmts</span><span class="p">,</span>
            <span class="n">Pass</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_pass</span><span class="p">,</span>
            <span class="n">BreakStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_break</span><span class="p">,</span>
            <span class="n">ContinueStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_continue</span><span class="p">,</span>
            <span class="n">ReturnStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_return_stmt</span><span class="p">,</span>
            <span class="n">Assert</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_assert_stmt</span><span class="p">,</span>
            <span class="n">Assignment</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_assignment</span><span class="p">,</span>
            <span class="n">Block</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_block</span><span class="p">,</span>
            <span class="n">FunctionDef</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_function_def</span><span class="p">,</span>
            <span class="n">TryStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_try_stmt</span><span class="p">,</span>
            <span class="n">WhileStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_while_stmt</span><span class="p">,</span>
            <span class="n">IfStmt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_if_stmt</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">Expression</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ASTNode</span><span class="p">,</span> <span class="n">SymbolicEnvironment</span><span class="p">],</span>
                                                                          <span class="n">EvalExprResult</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Disjunction</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_disjunction</span><span class="p">,</span>
            <span class="n">Conjunction</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_conjunction</span><span class="p">,</span>
            <span class="n">Inversion</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_inversion</span><span class="p">,</span>
            <span class="n">Comparison</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_comparison</span><span class="p">,</span>
            <span class="n">Sum</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_sum</span><span class="p">,</span>
            <span class="n">Term</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_term</span><span class="p">,</span>
            <span class="n">Factor</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_factor</span><span class="p">,</span>
            <span class="n">TupleNode</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_tuple</span><span class="p">,</span>
            <span class="n">TupleAccess</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_tuple_access</span><span class="p">,</span>
            <span class="n">FunctionCall</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_fun_call</span><span class="p">,</span>
            <span class="n">Param</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_param</span><span class="p">,</span>
            <span class="n">BooleanAtom</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_boolean</span><span class="p">,</span>
            <span class="n">IntAtom</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_int</span><span class="p">,</span>
            <span class="n">NameAtom</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_name</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Executing statement </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">WhileStmt</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_while_stmt</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="n">t</span><span class="p">](</span><span class="n">stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="c1"># Expression Statements</span>
            <span class="k">return</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">),</span> <span class="kc">None</span><span class="p">),</span> <span class="p">[])</span>
                                                     <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">)]</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">execute_stmts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmts</span><span class="p">:</span> <span class="n">Stmts</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_sequence</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">stmts</span><span class="o">.</span><span class="n">stmts</span><span class="p">),</span> <span class="n">environment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">execute_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmts</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ASTNode</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">leaves</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">stmts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">leaves</span> <span class="o">=</span> <span class="n">tree</span><span class="p">,</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">:</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">leaf</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">abrupt_completion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                    <span class="k">continue</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="p">)</span>

                <span class="k">assert</span> <span class="n">tree_contains</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">replace_in_tree</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>

            <span class="n">leaves</span> <span class="o">=</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">execute_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Pass</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">[])]</span>

    <span class="k">def</span> <span class="nf">execute_break</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">BreakStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">Break</span><span class="p">()),</span> <span class="kc">None</span><span class="p">),</span> <span class="p">[])]</span>

    <span class="k">def</span> <span class="nf">execute_continue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ContinueStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">Continue</span><span class="p">()),</span> <span class="kc">None</span><span class="p">),</span> <span class="p">[])]</span>

    <span class="k">def</span> <span class="nf">execute_return_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ReturnStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="n">children</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_expr_result</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span>
                                         <span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
                                         <span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span>
                                         <span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
                                         <span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">SymbolicReturn</span><span class="p">(</span><span class="n">value</span><span class="p">)),</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">execute_assert_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Assert</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="n">children</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_expr_result</span><span class="p">:</span>
            <span class="n">new_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">new_env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
                <span class="k">continue</span>
                
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">)</span>
            
            <span class="n">sat_env</span> <span class="o">=</span> <span class="n">new_env</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">viol_env</span> <span class="o">=</span> <span class="n">new_env</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

            <span class="n">sat_env_unsat</span> <span class="o">=</span> <span class="n">sat_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">()</span>
            <span class="n">viol_env_unsat</span> <span class="o">=</span> <span class="n">viol_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">sat_env_unsat</span><span class="p">:</span>
                <span class="n">viol_env_unsat</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">viol_env_unsat</span><span class="p">:</span>
                <span class="n">sat_env_unsat</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">sat_env_unsat</span><span class="p">:</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="ne">AssertionError</span><span class="p">()),</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
            <span class="k">elif</span> <span class="n">viol_env_unsat</span><span class="p">:</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">sat_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">viol_env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="ne">AssertionError</span><span class="p">()),</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">execute_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Assignment</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SET</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="n">children</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_expr_result</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">new_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">get_type_for_z3_expr</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="n">new_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_expr_result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_env</span> <span class="o">=</span> <span class="n">new_env</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>

            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">new_env</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">[]))</span>
        
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">execute_function_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">FunctionDef</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">f_name</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">name</span>
        <span class="n">ret_type</span> <span class="o">=</span> <span class="n">get_type</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate_param</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">params</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">SymbolicValueType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="n">environment</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

            <span class="n">block_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
            <span class="n">result</span><span class="p">:</span> <span class="n">EvalExprResult</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">block_result</span><span class="p">):</span>
                <span class="n">exc</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">abrupt_completion</span>
                <span class="k">if</span> <span class="n">exc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Missing return statement&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">SymbolicReturn</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">exc</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">z3_and</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">exc</span><span class="p">,</span> <span class="n">z3_and</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">path_constraints</span><span class="p">)))</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">ret_type</span><span class="p">,</span> <span class="n">func</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[])</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">evaluate_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="n">Param</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Variable</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">get_type</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">execute_try_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">TryStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[</span><span class="n">tree</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">leaf</span>
            <span class="n">exc</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">abrupt_completion</span>
            <span class="k">if</span> <span class="n">exc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">AbruptCompletionNoException</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">exc_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">caught_exc_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">&quot;builtins&quot;</span><span class="p">],</span> <span class="n">stmt</span><span class="o">.</span><span class="n">exc_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">caught_exc_type</span><span class="p">):</span>
                    <span class="n">catch_block_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">except_block</span><span class="p">,</span>
                                                    <span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">replace_in_tree</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">catch_block_tree</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">catch_block_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">replace_in_tree</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">catch_block_tree</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">execute_if_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">IfStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">eval_expr_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="n">result</span><span class="p">:</span> <span class="n">SET</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_expr_result</span><span class="p">:</span>
            <span class="n">new_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">new_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">new_env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
                <span class="k">continue</span>

            <span class="k">assert</span> <span class="n">z3</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="n">then_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">else_constraint</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

            <span class="n">then_env</span> <span class="o">=</span> <span class="n">new_env</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">then_constraint</span><span class="p">)</span>
            <span class="n">else_env</span> <span class="o">=</span> <span class="n">new_env</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">else_constraint</span><span class="p">)</span>

            <span class="n">then_env_unsat</span> <span class="o">=</span> <span class="n">then_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">()</span>
            <span class="n">else_env_unsat</span> <span class="o">=</span> <span class="n">else_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">then_env_unsat</span><span class="p">:</span>
                <span class="n">else_env_unsat</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">else_env_unsat</span><span class="p">:</span>
                <span class="n">then_env_unsat</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">then_env_unsat</span><span class="p">:</span>
                <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">then_block</span><span class="p">,</span> <span class="n">then_env</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">else_env_unsat</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span><span class="p">,</span> <span class="n">else_env</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">else_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">execute_while_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">WhileStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_guard_res</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">exc_node</span> <span class="o">=</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">exc_node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">exc_node</span><span class="p">,</span> <span class="p">[]))</span>
                <span class="k">continue</span>

            <span class="n">then_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">then_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">then_constraint</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">then_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">then_env</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">subtree</span><span class="p">):</span>
                    <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">leaf</span>
                    <span class="n">env</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span>
                    <span class="n">exc</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">abrupt_completion</span>
                    <span class="k">if</span> <span class="n">exc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">Continue</span><span class="p">):</span>
                            <span class="n">env</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">Break</span><span class="p">):</span>
                            <span class="n">env</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">replace_in_tree</span><span class="p">(</span>
                                <span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="n">while_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">replace_in_tree</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">while_tree</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="n">else_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="n">else_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">else_constraint</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">else_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span><span class="p">,</span> <span class="n">else_env</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">else_env</span><span class="p">,</span> <span class="s1">&#39;else:&#39;</span><span class="p">),</span> <span class="p">[</span><span class="n">subtree</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">else_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">execute_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">Block</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_sequence</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">stmts</span><span class="p">),</span> <span class="n">environment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)</span> <span class="k">else</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">constraint</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_interpretations</span><span class="p">[</span><span class="n">t</span><span class="p">](</span><span class="n">expr</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_unsat</span><span class="p">(</span><span class="n">constraint</span><span class="p">)]</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">evaluate_disjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Disjunction</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">sub_results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalExprResult</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">conjunctions</span><span class="p">]</span>

        <span class="n">result</span><span class="p">:</span> <span class="n">EvalExprResult</span> <span class="o">=</span> <span class="n">sub_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">sub_result</span> <span class="ow">in</span> <span class="n">sub_results</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">handle_binary_operation</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">sub_result</span><span class="p">,</span> <span class="s2">&quot;or&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">evaluate_conjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Conjunction</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">sub_results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalExprResult</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">inversions</span><span class="p">]</span>

        <span class="n">result</span><span class="p">:</span> <span class="n">EvalExprResult</span> <span class="o">=</span> <span class="n">sub_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">sub_result</span> <span class="ow">in</span> <span class="n">sub_results</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">handle_binary_operation</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">sub_result</span><span class="p">,</span> <span class="s2">&quot;and&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">evaluate_inversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Inversion</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">sub_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inversion</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">exc</span><span class="p">,</span> <span class="n">constr</span><span class="p">)</span> <span class="k">for</span> <span class="n">exc</span><span class="p">,</span> <span class="n">constr</span> <span class="ow">in</span> <span class="n">sub_result</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)]</span> <span class="o">+</span> \
               <span class="p">[(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">constr</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constr</span> <span class="ow">in</span> <span class="n">sub_result</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">evaluate_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Comparison</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">handle_binary_operation</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">handle_binary_operation</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Term</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">handle_binary_operation</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Factor</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">eval_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factor</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">symb</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">result</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="n">result</span><span class="p">,</span> <span class="n">constr</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">result</span><span class="p">,</span> <span class="n">constr</span> <span class="ow">in</span> <span class="n">eval_res</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eval_res</span>

    <span class="k">def</span> <span class="nf">evaluate_fun_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">FunctionCall</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">EvalExprResult</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">f_name</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">f_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;name &#39;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">&#39; is not defined&quot;</span><span class="p">)</span>

        <span class="n">args_result</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>

        <span class="n">combinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">args_result</span><span class="p">))</span>

        <span class="n">combination</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
            <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">path_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sub_result</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sub_value</span><span class="p">,</span> <span class="n">sub_constraint</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
                <span class="n">path_constraint</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">path_constraint</span><span class="p">,</span> <span class="n">sub_constraint</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wrap_exceptions</span><span class="p">((</span><span class="n">sub_value</span><span class="p">,</span> <span class="n">path_constraint</span><span class="p">)))</span>
                    <span class="k">break</span>

                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_value</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combination</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">ret_type</span><span class="p">,</span> <span class="n">fun</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span><span class="si">}</span><span class="s2">) takes </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;argument(s) but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="si">}</span><span class="s2"> were given&quot;</span><span class="p">)</span>

                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">evaluate_tuple_access</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">TupleAccess</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">target_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">atom</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">expr_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_tuple_access</span><span class="p">(</span><span class="n">target_res</span><span class="p">,</span> <span class="n">expr_res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_tuple_access</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tuple_result</span><span class="p">:</span> <span class="n">EvalExprResult</span><span class="p">,</span> <span class="n">expr_result</span><span class="p">:</span> <span class="n">EvalExprResult</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">EvalExprResult</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">atom_value</span><span class="p">,</span> <span class="n">atom_constraint</span> <span class="ow">in</span> <span class="n">tuple_result</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">atom_value</span><span class="p">,</span> <span class="n">atom_constraint</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom_value</span><span class="o">.</span><span class="n">sort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqSortRef</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">atom_value</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">),</span>
                               <span class="n">atom_constraint</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">expr_value</span><span class="p">,</span> <span class="n">expr_constraint</span> <span class="ow">in</span> <span class="n">expr_result</span><span class="p">:</span>
                <span class="n">conjunction</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">atom_constraint</span><span class="p">,</span> <span class="n">expr_constraint</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr_value</span><span class="p">,</span> <span class="n">conjunction</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">expr_value</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="o">!=</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">():</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;list indices must be integers, not </span><span class="si">{</span><span class="n">expr_value</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span>
                                   <span class="n">conjunction</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="n">atom_value</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqRef</span>

                <span class="c1"># In Python, indices can be in the closed interval [-len ; len - 1]</span>
                <span class="n">length_constraint_1</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">expr_value</span><span class="p">,</span>
                                             <span class="n">expr_value</span> <span class="o">&lt;</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="n">atom_value</span><span class="p">))</span>  <span class="c1"># [0 ; len - 1]</span>
                <span class="n">length_constraint_2</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">expr_value</span><span class="p">,</span>
                                             <span class="n">expr_value</span> <span class="o">&gt;=</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="n">atom_value</span><span class="p">))</span>  <span class="c1"># [-len ; -1]</span>

                <span class="n">expr</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">atom_value</span><span class="p">[</span><span class="n">expr_value</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">Z3_OP_ITE</span> <span class="ow">and</span> \
                        <span class="n">implies</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">conjunction</span><span class="p">,</span> <span class="n">length_constraint_1</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">conjunction</span><span class="p">,</span> <span class="n">length_constraint_1</span><span class="p">)))</span>

                <span class="n">expr</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">atom_value</span><span class="p">[</span><span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="n">atom_value</span><span class="p">)</span> <span class="o">+</span> <span class="n">expr_value</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">Z3_OP_ITE</span> <span class="ow">and</span> \
                        <span class="n">implies</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">conjunction</span><span class="p">,</span> <span class="n">length_constraint_2</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">conjunction</span><span class="p">,</span> <span class="n">length_constraint_2</span><span class="p">)))</span>

                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;tuple index out of range&quot;</span><span class="p">),</span>
                               <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">conjunction</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">length_constraint_1</span><span class="p">),</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">length_constraint_2</span><span class="p">))))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">evaluate_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">NameAtom</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">environment</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">evaluate_boolean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">BooleanAtom</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">evaluate_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">IntAtom</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">number</span><span class="p">),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">evaluate_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">TupleNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">sub_results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalExprResult</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">elems</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sub_results</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">z3</span><span class="o">.</span><span class="n">Empty</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">SeqSort</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">())),</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))]</span>
        
        <span class="n">result</span><span class="p">:</span> <span class="n">OrderedSet</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]]</span> <span class="o">=</span> <span class="n">OrderedSet</span><span class="p">([])</span>

        <span class="n">combinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">sub_results</span><span class="p">))</span>

        <span class="n">combination</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
            <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">path_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sub_result</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sub_value</span><span class="p">,</span> <span class="n">sub_constraint</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
                <span class="n">path_constraint</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">path_constraint</span><span class="p">,</span> <span class="n">sub_constraint</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">wrap_exceptions</span><span class="p">((</span><span class="n">sub_value</span><span class="p">,</span> <span class="n">path_constraint</span><span class="p">)))</span>
                    <span class="k">break</span>

                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_value</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combination</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">sort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqSortRef</span><span class="p">)</span> <span class="k">else</span> <span class="n">z3</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">path_constraint</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">sort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">SeqSortRef</span><span class="p">)</span> <span class="k">else</span> <span class="n">z3</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]),</span> <span class="n">path_constraint</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">unwrap_exceptions</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ExceptionWrapper</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for exception objects with support for equality checks and hashing.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="ne">Exception</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exc</span> <span class="o">=</span> <span class="n">exc</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exc</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exc</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">exc</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span>


<span class="k">def</span> <span class="nf">wrap_exceptions</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">])</span> <span class="o">-&gt;</span> \
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]:</span>
    <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">ExceptionWrapper</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)</span> <span class="k">else</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span>


<span class="k">def</span> <span class="nf">unwrap_exceptions</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">])</span> <span class="o">-&gt;</span> \
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]:</span>
    <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">exc</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ExceptionWrapper</span><span class="p">)</span> <span class="k">else</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span>


<span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">SET</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">SET</span><span class="p">]:</span>
    <span class="n">node</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">tree</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">children</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tree</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">child</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s give it a try:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">program</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">x = 2 * y</span>
<span class="s2">if x &lt; 0:</span>
<span class="s2">    x = -x</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">display_program</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)</span>

<span class="n">env</span> <span class="o">=</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="n">SymbolicStore</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">to_z3</span><span class="p">(),</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">to_z3</span><span class="p">()}))</span>
<span class="n">interpreter</span> <span class="o">=</span> <span class="n">SymbolicInterpreter</span><span class="p">()</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">program</span><span class="p">),</span> <span class="n">env</span><span class="p">)</span>

<span class="n">display_set</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
</pre></div>
</div>
<img alt="_images/symbolic_interpreter_56_1.svg" src="_images/symbolic_interpreter_56_1.svg" /></div>
</div>
<p>To try out something more complex, we revisit the linear search method from <a class="reference internal" href="minipy.html#minipy"><span class="std std-ref">Parser and Interpreter for minipy</span></a> (we slightly simplified the code, which originally should merely illustrate the extent of the minipy language).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">program</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def find(needle: int, haystack: tuple) -&gt; int:</span>
<span class="s2">    i = 0</span>
<span class="s2">    while i &lt; len(haystack):</span>
<span class="s2">        if haystack[i] == needle:</span>
<span class="s2">            break</span>
<span class="s2">        </span>
<span class="s2">        i = i + 1</span>
<span class="s2">    else:</span>
<span class="s2">        return -1</span>
<span class="s2">    </span>
<span class="s2">    return i</span>

<span class="s2">t = (1, 2, 3, 4, )</span>
<span class="s2">r = find(x, t)</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">display_program</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">needle</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">haystack</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">:</span>
            <span class="k">break</span>
        
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">i</span>

<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Instead of executing this program with a concrete “needle” value, we use a symbolic input <code class="docutils literal notranslate"><span class="pre">x</span></code>. Let’s have a look at the result:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">env</span> <span class="o">=</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="n">SymbolicStore</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">to_z3</span><span class="p">()}))</span>
<span class="n">interpreter</span> <span class="o">=</span> <span class="n">SymbolicInterpreter</span><span class="p">()</span>

<span class="k">with</span> <span class="n">ExpectError</span><span class="p">(</span><span class="n">print_traceback</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">program</span><span class="p">),</span> <span class="n">env</span><span class="p">)</span>
    <span class="n">display_set</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>NameError: name &#39;len&#39; is not defined (expected)
</pre></div>
</div>
</div>
</div>
<p>Ooops… Apparently, the interpreter does not know the <code class="docutils literal notranslate"><span class="pre">len</span></code> function which is built into Python. This is not surprising: Even the concrete interpreter has to be told about existing built-in functions. For the symbolic interpreter, the situation is much more complex, since we cannot call a built-in Python function with symbolic arguments. There are two ways to approach this problem:</p>
<ol class="simple">
<li><p>Implement the <code class="docutils literal notranslate"><span class="pre">len</span></code> function in minipy and add it to our program.</p></li>
<li><p>Summarize the <code class="docutils literal notranslate"><span class="pre">len</span></code> function with a symbolic expression.</p></li>
</ol>
<p>Option (2) corresponds to the concept of <em>function summaries</em> or <em>contracts</em> <span id="id5">[<a class="reference internal" href="transparent_function_execution.html#id173"><span>ABB+16</span></a>]</span> <span id="id6">[<a class="reference internal" href="#id155"><span>BCCDElia+18</span></a>]</span>. Such a summary is basically a conjunction of pre- and postcondition pairs, such that if a precondition holds in the current state, the postcondition can be assumed after function execution. We choose this option to teach the symbolic interpreter about the <code class="docutils literal notranslate"><span class="pre">len</span></code> function, since it would be rather impractical to add full implementations of all used library functions to each analyzed program. Furthermore, summaries are a central concept of <em>compositional symbolic execution</em> <span id="id7">[<a class="reference internal" href="#id179"><span>AGT08</span></a>]</span> (see also <a class="reference internal" href="compositional.html#techniques-compositional-se"><span class="std std-ref">Compositional Symbolic Execution</span></a>). It allows to modularly execute one piece of code at a time to derive or prove its summary, while invoking other functions by their summaries instead of executing them repeatedly.</p>
<p>We extend the symbolic interpreter such that we can pass it a collection of predicates that will be considered in function calls whenever a function implementation is not available. Technically, we pass the interpreter a dictionary with predicate names as keys, and triples of argument sorts, target sort, and a Callable producing a symbolic value from the given arguments as values. For the <code class="docutils literal notranslate"><span class="pre">len</span></code> function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">predicates</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;len&quot;</span><span class="p">:</span> <span class="p">((</span><span class="n">z3</span><span class="o">.</span><span class="n">SeqSort</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">()),),</span> <span class="n">z3</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">z3</span><span class="o">.</span><span class="n">Length</span><span class="p">)}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">(</span><span class="n">SymbolicInterpreter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">predicates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicates</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="p">{}</span> <span class="k">if</span> <span class="n">predicates</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">predicates</span>

    <span class="k">def</span> <span class="nf">evaluate_fun_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">FunctionCall</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalExprResult</span><span class="p">:</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">EvalExprResult</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">f_name</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">f_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span> <span class="ow">and</span> <span class="n">f_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicates</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;name &#39;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">&#39; is not defined&quot;</span><span class="p">)</span>

        <span class="n">args_result</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>

        <span class="n">combinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">args_result</span><span class="p">))</span>

        <span class="n">combination</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
            <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">path_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sub_result</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">SymbolicValueType</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sub_value</span><span class="p">,</span> <span class="n">sub_constraint</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
                <span class="n">path_constraint</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">path_constraint</span><span class="p">,</span> <span class="n">sub_constraint</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wrap_exceptions</span><span class="p">((</span><span class="n">sub_value</span><span class="p">,</span> <span class="n">path_constraint</span><span class="p">)))</span>
                    <span class="k">break</span>

                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_value</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combination</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">ret_type</span><span class="p">,</span> <span class="n">fun</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span><span class="si">}</span><span class="s2">) takes </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;argument(s) but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="si">}</span><span class="s2"> were given&quot;</span><span class="p">)</span>

                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicates</span><span class="p">:</span>
                <span class="n">params_sorts</span><span class="p">,</span> <span class="n">ret_sort</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicates</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params_sorts</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">params_sorts</span><span class="p">))</span><span class="si">}</span><span class="s2">) takes </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">params_sorts</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;argument(s) but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="si">}</span><span class="s2"> were given&quot;</span><span class="p">)</span>
                <span class="n">call_result</span><span class="p">:</span> <span class="n">SymbolicValueType</span> <span class="o">=</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">call_result</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="o">==</span> <span class="n">ret_sort</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">call_result</span><span class="p">,</span> <span class="n">path_constraint</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_output_scroll tag_full-width docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">env</span> <span class="o">=</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="n">SymbolicStore</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">to_z3</span><span class="p">()}))</span>
<span class="n">interpreter</span> <span class="o">=</span> <span class="n">SymbolicInterpreter</span><span class="p">(</span><span class="n">predicates</span><span class="o">=</span><span class="n">predicates</span><span class="p">)</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">program</span><span class="p">),</span> <span class="n">env</span><span class="p">)</span>
<span class="n">display_set</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/symbolic_interpreter_64_0.svg" src="_images/symbolic_interpreter_64_0.svg" /></div>
</div>
<p>Since the picture is a little oversized, here come the leaves of the tree:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">display_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">SET</span><span class="p">):</span>
    <span class="n">leaves</span> <span class="o">=</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">:</span>
        <span class="n">display_html</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">to_html</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">({1&nbsp;=&nbsp;x}, None, {x: x, t: Concat(Unit(1), Concat(Unit(2), Concat(Unit(3), Unit(4)))), r: 0})</div><div class="output text_html">({2&nbsp;=&nbsp;x}, None, {x: x, t: Concat(Unit(1), Concat(Unit(2), Concat(Unit(3), Unit(4)))), r: 1})</div><div class="output text_html">({3&nbsp;=&nbsp;x}, None, {x: x, t: Concat(Unit(1), Concat(Unit(2), Concat(Unit(3), Unit(4)))), r: 2})</div><div class="output text_html">({4&nbsp;=&nbsp;x}, None, {x: x, t: Concat(Unit(1), Concat(Unit(2), Concat(Unit(3), Unit(4)))), r: 3})</div><div class="output text_html">({&not;(3&nbsp;=&nbsp;x)&nbsp;&and;&nbsp;&not;(4&nbsp;=&nbsp;x)&nbsp;&and;&nbsp;&not;(1&nbsp;=&nbsp;x)&nbsp;&and;&nbsp;&not;(2&nbsp;=&nbsp;x)}, None, {x: x, t: Concat(Unit(1), Concat(Unit(2), Concat(Unit(3), Unit(4)))), r: -1})</div></div>
</div>
<p>The flat shape of the tree reveals one of the characteristics of our symbolic interpreter: Since function calls are evaluated as expressions, we do not see the SET corresponding to the execution of the function body. In <a class="reference internal" href="transparent_function_execution.html#techniques-transparent-function-execution"><span class="std std-ref">Transparent Symbolic Execution of Function Calls</span></a>, we describe how to transparently integrate SETs corresponding to called functions. Apart from that, the result is as expected: If <code class="docutils literal notranslate"><span class="pre">x</span></code> occurs in <code class="docutils literal notranslate"><span class="pre">t</span></code> (i.e., its value is between 1 and 4), the result value of variable <code class="docutils literal notranslate"><span class="pre">r</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">x</span></code>, and -1 otherwise.</p>
<p>But what happens if we also leave the value of <code class="docutils literal notranslate"><span class="pre">t</span></code> symbolic? In that case, the interpreter would continue unrolling the loop until the stack overflows (we do not demonstrate this here since a timeout is hard to implement in Python). In presence of a symbolic tuple <code class="docutils literal notranslate"><span class="pre">t</span></code>, we obtain an <em>unbounded loop</em>. A straightforward to deal with such unbounded loops solution is to only unroll loops until a maximum depth. We extend the symbolic interpreter with a depth bound for loops.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SymbolicInterpreter</span><span class="p">(</span><span class="n">SymbolicInterpreter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">loop_unrolling_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">predicates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">z3</span><span class="o">.</span><span class="n">SortRef</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">predicates</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_unrolling_threshold</span> <span class="o">=</span> <span class="n">loop_unrolling_threshold</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">,</span>
                <span class="n">loop_unrolling_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Executing statement </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>

        <span class="n">loop_unrolling_threshold</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">loop_unrolling_threshold</span> <span class="k">if</span> <span class="n">loop_unrolling_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_unrolling_threshold</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">WhileStmt</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_while_stmt</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">,</span> <span class="n">loop_unrolling_threshold</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stmt_interpretations</span><span class="p">[</span><span class="n">t</span><span class="p">](</span><span class="n">stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="c1"># Expression Statements</span>
            <span class="k">return</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">),</span> <span class="kc">None</span><span class="p">),</span> <span class="p">[])</span>
                                                     <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">)]</span>

        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">execute_while_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">WhileStmt</span><span class="p">,</span> <span class="n">environment</span><span class="p">:</span> <span class="n">SymbolicEnvironment</span><span class="p">,</span>
                           <span class="n">loop_unrolling_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SET</span><span class="p">:</span>
        <span class="n">loop_unrolling_threshold</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">loop_unrolling_threshold</span> <span class="ow">is</span> <span class="kc">None</span>
                                    <span class="k">else</span> <span class="n">loop_unrolling_threshold</span><span class="p">)</span>

        <span class="n">eval_guard_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">guard</span><span class="p">,</span> <span class="n">environment</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">code</span><span class="p">),</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">eval_guard_res</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="n">exc_node</span> <span class="o">=</span> <span class="n">SETNode</span><span class="p">(</span><span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">exc_node</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">exc_node</span><span class="p">,</span> <span class="p">[]))</span>
                <span class="k">continue</span>

            <span class="n">then_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">then_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">then_constraint</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">then_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">()</span> <span class="ow">and</span> <span class="n">loop_unrolling_threshold</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">then_env</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">get_leaves</span><span class="p">(</span><span class="n">subtree</span><span class="p">):</span>
                    <span class="n">node</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">leaf</span>
                    <span class="n">env</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">environment</span>
                    <span class="n">exc</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">abrupt_completion</span>
                    <span class="k">if</span> <span class="n">exc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">Continue</span><span class="p">):</span>
                            <span class="n">env</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">Break</span><span class="p">):</span>
                            <span class="n">env</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">set_abrupt_completion</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">replace_in_tree</span><span class="p">(</span>
                                <span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="p">(</span><span class="n">SETNode</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="n">while_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">loop_unrolling_threshold</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">replace_in_tree</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">while_tree</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="n">else_constraint</span><span class="p">:</span> <span class="n">z3</span><span class="o">.</span><span class="n">BoolRef</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="n">else_env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">else_constraint</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">else_env</span><span class="o">.</span><span class="n">unsatisfiable</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">subtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_block</span><span class="p">,</span> <span class="n">else_env</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">else_env</span><span class="p">,</span> <span class="s1">&#39;else:&#39;</span><span class="p">),</span> <span class="p">[</span><span class="n">subtree</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SETNode</span><span class="p">(</span><span class="n">else_env</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="p">[]))</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>This time, we directly execute the body of the <code class="docutils literal notranslate"><span class="pre">find</span></code> function to obtain an SET for the actual loop:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">program</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;i = 0</span>
<span class="s2">while i &lt; len(haystack):</span>
<span class="s2">    if haystack[i] == needle:</span>
<span class="s2">        break</span>
<span class="s2">    i = i + 1</span>
<span class="s2">else:</span>
<span class="s2">    return -1</span>

<span class="s2">return i</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">display_program</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_output_scroll tag_full-width docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">needle</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;needle&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">)</span>
<span class="n">haystack</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;haystack&quot;</span><span class="p">,</span> <span class="n">TUPLE_TYPE</span><span class="p">)</span>

<span class="n">env</span> <span class="o">=</span> <span class="n">SymbolicEnvironment</span><span class="p">(</span><span class="n">SymbolicStore</span><span class="p">({</span><span class="n">needle</span><span class="p">:</span> <span class="n">needle</span><span class="o">.</span><span class="n">to_z3</span><span class="p">(),</span> <span class="n">haystack</span><span class="p">:</span> <span class="n">haystack</span><span class="o">.</span><span class="n">to_z3</span><span class="p">()}))</span>
<span class="n">interpreter</span> <span class="o">=</span> <span class="n">SymbolicInterpreter</span><span class="p">(</span><span class="n">predicates</span><span class="o">=</span><span class="n">predicates</span><span class="p">,</span> <span class="n">loop_unrolling_threshold</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="n">program</span><span class="p">),</span> <span class="n">env</span><span class="p">)</span>

<span class="n">display_set</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/symbolic_interpreter_72_0.svg" src="_images/symbolic_interpreter_72_0.svg" /></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">({&not;(Length(haystack)&nbsp;&le;&nbsp;0),&nbsp;If(Length(haystack)&nbsp;&le;&nbsp;0,<BR/>&nbsp;&nbsp;&nbsp;seq.nth_u(haystack,&nbsp;0),<BR/>&nbsp;&nbsp;&nbsp;seq.nth_i(haystack,&nbsp;0))&nbsp;=<BR/>needle}, SymbolicReturn(0), {needle: needle, haystack: haystack, i: 0})</div><div class="output text_html">({&not;(Length(haystack)&nbsp;&le;&nbsp;1),&nbsp;If(Length(haystack)&nbsp;&le;&nbsp;1,<BR/>&nbsp;&nbsp;&nbsp;seq.nth_u(haystack,&nbsp;1),<BR/>&nbsp;&nbsp;&nbsp;seq.nth_i(haystack,&nbsp;1))&nbsp;=<BR/>needle,&nbsp;&not;(If(Length(haystack)&nbsp;&le;&nbsp;0,<BR/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq.nth_u(haystack,&nbsp;0),<BR/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq.nth_i(haystack,&nbsp;0))&nbsp;=<BR/>&nbsp;&nbsp;needle)}, SymbolicReturn(1), {needle: needle, haystack: haystack, i: 1})</div><div class="output text_html">({&not;(Length(haystack)&nbsp;&le;&nbsp;1),&nbsp;&not;(If(Length(haystack)&nbsp;&le;&nbsp;1,<BR/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq.nth_u(haystack,&nbsp;1),<BR/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq.nth_i(haystack,&nbsp;1))&nbsp;=<BR/>&nbsp;&nbsp;needle),&nbsp;Length(haystack)&nbsp;&le;&nbsp;2,&nbsp;&not;(If(Length(haystack)&nbsp;&le;&nbsp;0,<BR/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq.nth_u(haystack,&nbsp;0),<BR/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq.nth_i(haystack,&nbsp;0))&nbsp;=<BR/>&nbsp;&nbsp;needle)}, SymbolicReturn(-1), {needle: needle, haystack: haystack, i: 2})</div><div class="output text_html">({Length(haystack)&nbsp;&le;&nbsp;1,&nbsp;&not;(Length(haystack)&nbsp;&le;&nbsp;0),&nbsp;&not;(If(Length(haystack)&nbsp;&le;&nbsp;0,<BR/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq.nth_u(haystack,&nbsp;0),<BR/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq.nth_i(haystack,&nbsp;0))&nbsp;=<BR/>&nbsp;&nbsp;needle)}, SymbolicReturn(-1), {needle: needle, haystack: haystack, i: 1})</div><div class="output text_html">({Length(haystack)&nbsp;&le;&nbsp;0}, SymbolicReturn(-1), {needle: needle, haystack: haystack, i: 0})</div></div>
</div>
<p>For each tuple index within our set bound of 2, we obtain two leaves: One where the searched-for element has been found (the abrupt completion flag is set to <code class="docutils literal notranslate"><span class="pre">SymbolicReturn(index)</span></code>, where <code class="docutils literal notranslate"><span class="pre">index</span></code> is the first position where <code class="docutils literal notranslate"><span class="pre">needle</span></code> has been found), and one where it has not been found (<code class="docutils literal notranslate"><span class="pre">SymbolicReturn(-1)</span></code>). Additionally, we have one leaf for the case where the tuple is empty (Length(haystack) ≤ 0).</p>
<p>In <a class="reference internal" href="static_loops.html#techniques-loops-static-se"><span class="std std-ref">Loops in Static Symbolic Execution</span></a>, we introduce a technique based on <em>loop invariants</em> (summaries for loops), which allows to symbolically execute loops (in an online, static symbolic interpreter) without depth bounds.</p>
<p>But what does it actually mean to stop SE after a given bound has exceeded? What is the effect of choosing coarse summaries for functions or loops? And how can we check whether the implementation of the symbolic interpreter discussed in this section is correct? These questions are related to the <em>semantics</em> of symbolic transition systems, which we discuss next.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p id="id8"><dl class="citation">
<dt class="label" id="id177"><span class="brackets">ABB+16</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p>Wolfgang Ahrendt, Bernhard Beckert, Richard Bubel, Reiner Hähnle, Peter H. Schmitt, and Mattias Ulbrich, editors. <em>Deductive Software Verification – The KeY Book</em>. Volume 10001 of LNCS. Springer, 2016. <a class="reference external" href="https://doi.org/10.1007/978-3-319-49812-6">doi:10.1007/978-3-319-49812-6</a>.</p>
</dd>
<dt class="label" id="id179"><span class="brackets"><a class="fn-backref" href="#id7">AGT08</a></span></dt>
<dd><p>Saswat Anand, Patrice Godefroid, and Nikolai Tillmann. Demand-Driven Compositional Symbolic Execution. In <em>Proc. of the 14th Intl. Conf.  on Tools and Algorithms for the Construction and Analysis of Systems</em>, 367–381. Springer, 2008.</p>
</dd>
<dt class="label" id="id155"><span class="brackets">BCCDElia+18</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id4">2</a>,<a href="#id6">3</a>)</span></dt>
<dd><p>Roberto Baldoni, Emilio Coppa, Daniele Cono D'Elia, Camil Demetrescu, and Irene Finocchi. A Survey of Symbolic Execution Techniques. <em>ACM Comput. Surv.</em>, 51(3):50:1–50:39, 2018. <a class="reference external" href="https://doi.org/10.1145/3182657">doi:10.1145/3182657</a>.</p>
</dd>
</dl>
</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="floor-division"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>See <a class="reference external" href="https://docs.python.org/3/reference/expressions.html#index-67">https://docs.python.org/3/reference/expressions.html#index-67</a></p>
</dd>
</dl>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="semantics.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Syntax and Semantics of Symbolic States</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="correctness.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Correctness of Symbolic Transitions</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Dominic Steinhöfel<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>